// Code generated by protoc-gen-go. DO NOT EDIT.
// source: io/core/a_rpc_others.proto

package io

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() {
	proto.RegisterFile("io/core/a_rpc_others.proto", fileDescriptor_e445775eea8ad529)
}

var fileDescriptor_e445775eea8ad529 = []byte{
	// 2102 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4d, 0x6c, 0x1c, 0x49,
	0x15, 0x56, 0x4f, 0xfe, 0xcb, 0x4e, 0x9c, 0x94, 0x1d, 0x3b, 0xee, 0x24, 0x4e, 0x6d, 0xef, 0x46,
	0x2c, 0x81, 0xcc, 0xcc, 0x3a, 0xc9, 0x1e, 0x72, 0x40, 0x8c, 0x7f, 0xb2, 0xb2, 0x93, 0x5d, 0xbc,
	0xfe, 0x21, 0x12, 0x28, 0x84, 0x9a, 0xee, 0x37, 0x33, 0x15, 0xf7, 0x54, 0xf5, 0x56, 0x55, 0x8f,
	0x31, 0x51, 0x24, 0xc8, 0x72, 0x00, 0x89, 0xb0, 0xd2, 0xc0, 0x19, 0x24, 0x38, 0x20, 0xad, 0x90,
	0x10, 0x7b, 0xe0, 0xb2, 0xec, 0x8d, 0x03, 0xe2, 0x8a, 0xc4, 0x05, 0x09, 0x0e, 0x20, 0xc1, 0x09,
	0x4e, 0x88, 0x23, 0xa8, 0xaa, 0x7a, 0xa6, 0x7b, 0xec, 0x99, 0x64, 0x13, 0x12, 0x84, 0xf6, 0x12,
	0xa7, 0xeb, 0xd5, 0xfb, 0xea, 0xbd, 0xaf, 0xde, 0x5f, 0x0d, 0xf2, 0x99, 0xa8, 0x84, 0x42, 0x42,
	0x85, 0xde, 0x95, 0x49, 0x78, 0x57, 0xe8, 0x16, 0x48, 0x55, 0x4e, 0xa4, 0xd0, 0x02, 0x97, 0x98,
	0xf0, 0xcf, 0x35, 0x85, 0x68, 0xc6, 0x50, 0xa1, 0x09, 0xab, 0x50, 0xce, 0x85, 0xa6, 0x9a, 0x09,
	0x9e, 0xed, 0xf0, 0xcf, 0x66, 0x52, 0xfb, 0x55, 0x4f, 0x1b, 0x15, 0x68, 0x27, 0x7a, 0x37, 0x13,
	0x7e, 0xd6, 0xfe, 0x09, 0x2f, 0x37, 0x81, 0x5f, 0x56, 0x3b, 0xb4, 0xd9, 0x04, 0x59, 0x11, 0x89,
	0x55, 0x1f, 0x02, 0x35, 0x67, 0x0d, 0x69, 0xb7, 0x05, 0xcf, 0xfe, 0xdc, 0x15, 0xf5, 0x7b, 0x10,
	0xea, 0x9e, 0xfc, 0x5c, 0x2e, 0x8f, 0x98, 0xd2, 0x92, 0xd5, 0x53, 0xa3, 0x9e, 0x49, 0x67, 0x72,
	0x69, 0x22, 0x85, 0xd1, 0xdb, 0x2f, 0x68, 0x83, 0x52, 0xb4, 0x09, 0x99, 0x60, 0x32, 0x17, 0xdc,
	0x13, 0xf5, 0x6c, 0xd1, 0x2f, 0xc0, 0xd0, 0x26, 0xe3, 0xb4, 0x70, 0xc4, 0x74, 0x2e, 0x6b, 0xb0,
	0x58, 0x83, 0xec, 0x71, 0x90, 0xaf, 0x33, 0xae, 0xa1, 0x29, 0x8b, 0x4a, 0x98, 0x89, 0x4a, 0xaa,
	0x40, 0xda, 0x7f, 0xdc, 0xda, 0xfc, 0x5f, 0x11, 0x3a, 0xb4, 0xa5, 0x40, 0x2a, 0xfc, 0x79, 0x84,
	0x42, 0x09, 0x54, 0x83, 0xf9, 0xc4, 0x63, 0x65, 0x26, 0xca, 0x6f, 0xc1, 0x8e, 0xf9, 0xf0, 0x27,
	0x0b, 0x1f, 0xeb, 0xa0, 0x12, 0xc1, 0x15, 0x04, 0x27, 0x1f, 0xfe, 0xee, 0x2f, 0xdf, 0x2f, 0xa1,
	0xe0, 0x90, 0x85, 0xbb, 0xee, 0x5d, 0xc2, 0xd7, 0xd0, 0x11, 0xee, 0x36, 0x0d, 0xaa, 0x1f, 0x31,
	0x1f, 0xab, 0xb7, 0x37, 0x83, 0x29, 0xab, 0x72, 0x22, 0x38, 0xe6, 0xcc, 0xe0, 0xb0, 0x63, 0xd4,
	0x5e, 0x47, 0x87, 0x3b, 0x20, 0x59, 0x63, 0x17, 0x1f, 0x36, 0x1b, 0x57, 0x22, 0xdf, 0x6a, 0x2f,
	0x08, 0x11, 0x03, 0xe5, 0xc1, 0x8c, 0x55, 0x3a, 0xe5, 0x8f, 0x3b, 0x25, 0xb7, 0xd5, 0xe8, 0x7d,
	0x05, 0xcd, 0x48, 0x50, 0xc0, 0xa3, 0x2f, 0x9a, 0x25, 0x16, 0x5a, 0x57, 0x97, 0xdb, 0x94, 0xc5,
	0x78, 0xba, 0xec, 0x62, 0xa1, 0xdc, 0x8b, 0x85, 0xf2, 0xb2, 0x89, 0x85, 0x41, 0xe0, 0x39, 0x0b,
	0x7c, 0x26, 0x98, 0x2c, 0x02, 0x57, 0x1c, 0xa4, 0xc1, 0x7f, 0x13, 0x1d, 0x69, 0x82, 0xb6, 0xee,
	0x8c, 0xc2, 0xb3, 0xc4, 0xbc, 0xe1, 0x36, 0xf5, 0x89, 0x39, 0x6d, 0x71, 0x27, 0xf0, 0x71, 0x87,
	0x9b, 0x48, 0xd1, 0x60, 0x31, 0xe0, 0xab, 0xe8, 0x50, 0x2c, 0x9a, 0x8c, 0xe3, 0x09, 0xa3, 0xb4,
	0x28, 0x21, 0x02, 0xae, 0x19, 0x8d, 0x55, 0xce, 0xcf, 0x29, 0xab, 0x39, 0x16, 0x1c, 0xae, 0xd8,
	0x9d, 0xc6, 0x88, 0x35, 0x74, 0xdc, 0x58, 0xa4, 0xd7, 0xa8, 0x52, 0x3b, 0x42, 0x46, 0xfb, 0xb5,
	0x47, 0xd8, 0x16, 0x4c, 0x5b, 0xb0, 0x93, 0xfe, 0x98, 0x33, 0xc3, 0xa2, 0x38, 0xda, 0x4e, 0x1b,
	0x0f, 0x7b, 0x80, 0xeb, 0x66, 0xfd, 0x16, 0xe3, 0xdb, 0x78, 0xdc, 0x20, 0x1b, 0x4f, 0x38, 0x6d,
	0xc3, 0x48, 0xd8, 0x0b, 0x16, 0x76, 0x36, 0x98, 0x2a, 0xc0, 0x56, 0x92, 0x0c, 0xcc, 0xe0, 0x53,
	0x74, 0x22, 0x6c, 0x51, 0xde, 0x84, 0xbe, 0xc9, 0xd3, 0x06, 0x78, 0xe0, 0xbc, 0x15, 0x9e, 0xa4,
	0xfa, 0x49, 0x47, 0xf8, 0x23, 0x8f, 0xf8, 0x2a, 0x7a, 0xa9, 0x09, 0x7a, 0xcd, 0xe5, 0x96, 0xba,
	0x21, 0xa4, 0xb1, 0xfa, 0xed, 0x14, 0xe4, 0xee, 0x12, 0x24, 0x12, 0x42, 0xaa, 0x21, 0xc2, 0x27,
	0xdc, 0xa9, 0xbd, 0xc4, 0x71, 0x77, 0x9f, 0xe9, 0x04, 0xe7, 0xec, 0x11, 0xd3, 0x78, 0xaa, 0x97,
	0xa1, 0xca, 0x9d, 0xf5, 0x8e, 0x01, 0xa9, 0x7a, 0x78, 0x13, 0xf9, 0x85, 0x13, 0x9e, 0x0a, 0x3a,
	0x8b, 0x57, 0x3c, 0x91, 0x43, 0xf7, 0x50, 0xb7, 0xd0, 0xcc, 0x08, 0xbb, 0x5d, 0xc2, 0xdc, 0xb0,
	0xa9, 0xac, 0x06, 0xf1, 0xf2, 0x30, 0x1d, 0x34, 0x35, 0x66, 0xca, 0xdc, 0x67, 0xd5, 0xc3, 0x2b,
	0xe8, 0xe4, 0x5e, 0x63, 0x1f, 0x83, 0x37, 0x6b, 0xf1, 0x26, 0x83, 0x13, 0x39, 0x5e, 0x0e, 0xb5,
	0x50, 0x84, 0x5a, 0xd8, 0xdd, 0x4a, 0x59, 0x34, 0x98, 0x95, 0x7b, 0x50, 0xf0, 0xa9, 0x1c, 0x85,
	0x45, 0x95, 0xfb, 0x2c, 0x7a, 0x80, 0x43, 0x44, 0x72, 0x8c, 0x1a, 0x8f, 0x36, 0xa1, 0x9d, 0xc4,
	0x54, 0xc3, 0xc2, 0xee, 0x46, 0x4b, 0x48, 0xbd, 0x28, 0x22, 0xe8, 0x63, 0x9e, 0x2b, 0x60, 0x16,
	0xe4, 0xeb, 0xa0, 0xd2, 0x78, 0xe8, 0x21, 0x2a, 0x74, 0x87, 0xdc, 0x41, 0x78, 0x3f, 0x95, 0x78,
	0xa6, 0x00, 0xb7, 0xa1, 0xa9, 0x4e, 0x95, 0xa3, 0x60, 0xd0, 0xf6, 0x2c, 0xbe, 0xf0, 0xcc, 0x1e,
	0x46, 0xef, 0x2b, 0xab, 0xf2, 0xa0, 0xea, 0xe1, 0xb7, 0xd1, 0x58, 0x01, 0xfe, 0x63, 0xe2, 0xfa,
	0x16, 0x77, 0x0a, 0xe3, 0x1c, 0x37, 0x87, 0x9c, 0x7f, 0xef, 0x00, 0x3a, 0xfa, 0xa6, 0xab, 0xfa,
	0x0a, 0xff, 0xda, 0x43, 0x63, 0x26, 0x0b, 0xb3, 0x05, 0x77, 0x5d, 0xd9, 0x87, 0x9f, 0x91, 0x13,
	0xfc, 0xc8, 0xeb, 0xd6, 0xbe, 0xed, 0xe1, 0xf1, 0x0d, 0xe0, 0x11, 0xe9, 0x09, 0x6f, 0x2c, 0xda,
	0x22, 0xad, 0x08, 0x25, 0x1c, 0x76, 0x48, 0xd6, 0x47, 0x08, 0xe3, 0x44, 0xb7, 0x80, 0x44, 0x54,
	0xd3, 0x3a, 0x55, 0x40, 0x28, 0x8f, 0x48, 0x9a, 0x44, 0x6e, 0x67, 0x1c, 0x13, 0x09, 0x31, 0x74,
	0x28, 0xd7, 0xc4, 0xe4, 0x11, 0xa8, 0xf2, 0x6a, 0x15, 0x1d, 0xb8, 0x5a, 0xad, 0xe2, 0x4f, 0xa3,
	0x4f, 0x6d, 0xb6, 0x40, 0x02, 0x61, 0x06, 0x31, 0x91, 0xa2, 0x1e, 0x43, 0x9b, 0xec, 0x30, 0xdd,
	0xb2, 0x78, 0xcc, 0x24, 0xaa, 0x45, 0x2d, 0x5b, 0xe7, 0x8e, 0x07, 0x47, 0x7b, 0xad, 0xcb, 0x24,
	0xe2, 0x87, 0x9e, 0xe5, 0xa9, 0xef, 0xd6, 0xd0, 0xc4, 0xc8, 0xa4, 0xc1, 0x77, 0xbd, 0x6e, 0xed,
	0x6b, 0x78, 0xfc, 0x0d, 0xd0, 0x3d, 0x67, 0x94, 0xff, 0xfa, 0x3a, 0x68, 0xc9, 0xa0, 0x93, 0x59,
	0x99, 0x41, 0x2b, 0xd2, 0xa6, 0x3a, 0x6c, 0x31, 0xde, 0xb4, 0x46, 0x84, 0x92, 0x69, 0x90, 0xcc,
	0x9a, 0xd7, 0x61, 0x11, 0x44, 0xcf, 0x6a, 0xfd, 0x18, 0x3e, 0xd6, 0xb3, 0x5e, 0x55, 0xbd, 0xf9,
	0x0f, 0x4b, 0x68, 0x7c, 0xa9, 0xd0, 0xbe, 0xf1, 0xfb, 0x25, 0x74, 0xd2, 0xdc, 0xca, 0x6d, 0x88,
	0x43, 0xd1, 0x06, 0xd7, 0x4b, 0x6c, 0x88, 0xda, 0xff, 0x16, 0xf7, 0xae, 0xc3, 0x3b, 0x29, 0xa8,
	0xd1, 0x35, 0xec, 0x4f, 0x5e, 0xb7, 0xf6, 0x91, 0x87, 0xb1, 0xbd, 0xbb, 0x0c, 0x8f, 0x58, 0x14,
	0xbf, 0x6c, 0xd6, 0x8c, 0xbd, 0x3b, 0xd9, 0x32, 0x98, 0x65, 0xa2, 0x05, 0xa1, 0x9c, 0x30, 0x1e,
	0xb1, 0x0e, 0x8b, 0x52, 0x6a, 0xae, 0x2c, 0x14, 0xf2, 0x59, 0x7c, 0x5d, 0x9d, 0x33, 0x1a, 0x57,
	0xf1, 0x0c, 0x3a, 0xbd, 0x6e, 0x31, 0xc8, 0x0e, 0x55, 0x84, 0x0b, 0x4d, 0x1a, 0x22, 0xe5, 0x51,
	0x79, 0xf5, 0x22, 0x3a, 0x70, 0xad, 0x5a, 0xc5, 0x73, 0xe8, 0x9c, 0x43, 0x34, 0x62, 0x7b, 0xb6,
	0x36, 0xc5, 0x3f, 0x26, 0x20, 0xa5, 0x90, 0xe5, 0x7e, 0xdd, 0x29, 0x8e, 0x38, 0x15, 0x6b, 0xec,
	0x75, 0xef, 0xd2, 0xfc, 0x07, 0x07, 0xd1, 0xc1, 0x55, 0x51, 0x57, 0xf8, 0x8f, 0x1e, 0x3a, 0xc6,
	0xda, 0x89, 0x49, 0x5d, 0xd5, 0xc1, 0x53, 0xb6, 0x3f, 0xa9, 0xce, 0x8a, 0x5d, 0xe9, 0xd1, 0xd4,
	0x0b, 0xe9, 0x0f, 0xbc, 0x6e, 0xed, 0x07, 0x1e, 0x46, 0x4e, 0x4a, 0x16, 0x55, 0xc7, 0xbf, 0xb4,
	0x49, 0xb7, 0x21, 0x73, 0xc9, 0xde, 0x2e, 0x09, 0x55, 0xc7, 0xc6, 0x6f, 0x3d, 0x65, 0xb1, 0x25,
	0x6a, 0x51, 0x75, 0x88, 0x99, 0x8b, 0x9e, 0x81, 0x8a, 0x57, 0xd1, 0x81, 0xab, 0xaf, 0x5d, 0xc1,
	0x2f, 0xa1, 0x0b, 0x9b, 0x2d, 0x20, 0xa6, 0x11, 0xe7, 0xe7, 0x30, 0x45, 0xb4, 0x10, 0x24, 0xa6,
	0xb2, 0x09, 0xce, 0xdb, 0xa9, 0x60, 0xc2, 0x0c, 0x60, 0x95, 0x50, 0x75, 0xee, 0x3a, 0x97, 0x4c,
	0x94, 0xff, 0xd4, 0xb3, 0x93, 0x80, 0x75, 0x76, 0x6f, 0x84, 0xbb, 0xde, 0x2d, 0xea, 0xc1, 0x37,
	0xbc, 0x6e, 0x2d, 0xc1, 0x47, 0x4d, 0x74, 0x9b, 0x8d, 0xfe, 0xfc, 0x60, 0x64, 0xdf, 0x13, 0xf5,
	0x17, 0x15, 0xd5, 0x47, 0xf0, 0x21, 0x63, 0xb4, 0xaa, 0x7a, 0xf8, 0x87, 0x1e, 0x3a, 0xec, 0x2c,
	0xed, 0x57, 0xd8, 0xbe, 0x81, 0x0f, 0xbd, 0x6e, 0x8d, 0xe3, 0x23, 0x99, 0x81, 0xfe, 0x6b, 0x05,
	0xfb, 0x8c, 0x75, 0x59, 0xb8, 0xe5, 0xc7, 0x84, 0x42, 0x4a, 0x3b, 0xd2, 0x44, 0xc6, 0x62, 0xf6,
	0x5f, 0x25, 0x9d, 0xe1, 0xd4, 0x94, 0xed, 0xf9, 0x47, 0xb3, 0x68, 0x7c, 0x25, 0x1f, 0x4c, 0x15,
	0xfe, 0x66, 0x09, 0x61, 0x37, 0x76, 0x0e, 0x2c, 0xdb, 0x91, 0xa1, 0xb0, 0xb2, 0x28, 0x78, 0x83,
	0x35, 0x55, 0x3f, 0x8e, 0x7e, 0xeb, 0x75, 0x6b, 0x3f, 0xf6, 0xf0, 0xa4, 0x2b, 0x86, 0xa4, 0xa8,
	0xeb, 0xbf, 0xbc, 0x01, 0x5a, 0x91, 0x34, 0x21, 0x85, 0x09, 0x98, 0x84, 0x16, 0x20, 0xcd, 0xf6,
	0x3c, 0x4b, 0x24, 0x5d, 0x35, 0x1a, 0x57, 0xf0, 0x65, 0xf4, 0x99, 0x75, 0xd0, 0xa9, 0xe4, 0x10,
	0x91, 0x9d, 0x16, 0xb8, 0xb2, 0x6b, 0xda, 0x07, 0x89, 0x69, 0xb8, 0xad, 0x08, 0x4d, 0x75, 0x4b,
	0x48, 0xf6, 0x75, 0x37, 0x78, 0x5b, 0x06, 0xe6, 0x82, 0xd9, 0xe2, 0x34, 0xae, 0x8a, 0x1f, 0x26,
	0xbe, 0xfe, 0xe5, 0xa1, 0x89, 0xa6, 0x19, 0x8a, 0x0a, 0x04, 0x4c, 0x66, 0x8d, 0x45, 0x8b, 0x50,
	0xc4, 0x2b, 0x51, 0x6f, 0x60, 0x1a, 0xca, 0x4a, 0xf0, 0x4b, 0xaf, 0x5b, 0x7b, 0x80, 0x4f, 0x9a,
	0xab, 0x1d, 0x60, 0xe2, 0x62, 0x7e, 0xc7, 0x8f, 0xe3, 0x22, 0x70, 0x9e, 0x9d, 0x45, 0xb3, 0x5b,
	0xa3, 0xfc, 0x78, 0x52, 0x49, 0xb1, 0x7e, 0x56, 0x71, 0x79, 0xa4, 0x9f, 0x95, 0xfb, 0x49, 0xe6,
	0xcc, 0x83, 0xca, 0xfd, 0x30, 0xa6, 0x4a, 0xad, 0x44, 0x0f, 0xf0, 0x9f, 0x4b, 0x08, 0xbb, 0x2e,
	0xf5, 0x54, 0xb7, 0xff, 0xb3, 0x52, 0xb7, 0xf6, 0xad, 0x12, 0x9e, 0xdc, 0xb2, 0xaa, 0x83, 0x3e,
	0xcf, 0x6d, 0xf5, 0xba, 0x1e, 0x1f, 0x70, 0xfa, 0xd9, 0xab, 0xe9, 0x73, 0xa0, 0x67, 0xf5, 0xb6,
	0xa9, 0xb8, 0x57, 0xf0, 0x1a, 0x7a, 0x6b, 0x03, 0x64, 0x07, 0xa4, 0x39, 0x36, 0xe5, 0xb4, 0x43,
	0x59, 0x4c, 0xeb, 0x31, 0x94, 0xc9, 0x02, 0x0d, 0xb7, 0x89, 0x68, 0x34, 0x48, 0x43, 0x48, 0x32,
	0x7f, 0xad, 0xda, 0x56, 0xb6, 0x04, 0x4a, 0x48, 0x80, 0x6a, 0x22, 0x5d, 0x19, 0x25, 0x29, 0xd7,
	0x2c, 0x26, 0x2a, 0x0d, 0x43, 0x50, 0xaa, 0x91, 0xc6, 0x59, 0x7c, 0xf9, 0x8f, 0x8f, 0xaf, 0x7f,
	0x7a, 0x08, 0x47, 0x10, 0xc3, 0x1e, 0x96, 0x47, 0x84, 0xd8, 0xf0, 0x7e, 0xf6, 0x0b, 0xdb, 0xbc,
	0x27, 0x97, 0x2c, 0xcc, 0x20, 0xe3, 0xe7, 0xdd, 0xe2, 0x08, 0xc6, 0x9f, 0x5f, 0x74, 0x5d, 0x7a,
	0xda, 0xe8, 0xfa, 0x4d, 0x09, 0x4d, 0xbb, 0xda, 0xb2, 0xc1, 0xf8, 0xf6, 0x46, 0x5a, 0x57, 0xa1,
	0x64, 0xf6, 0xcd, 0xef, 0xba, 0xd4, 0xde, 0xd5, 0x7e, 0x7c, 0xbd, 0x57, 0xea, 0xd6, 0xfe, 0xee,
	0xe1, 0x33, 0x59, 0x75, 0x31, 0xfb, 0xc8, 0xc0, 0xc6, 0x7b, 0xf9, 0x10, 0xa6, 0x8c, 0x50, 0x15,
	0x84, 0x44, 0x09, 0xa2, 0x5b, 0x54, 0x13, 0xf3, 0xe2, 0xb9, 0xc9, 0x34, 0x09, 0x29, 0x27, 0x66,
	0xaa, 0x20, 0xb4, 0x3f, 0xad, 0x99, 0x5e, 0x4f, 0xb6, 0xd6, 0x6f, 0x11, 0xda, 0xd0, 0x20, 0x49,
	0x08, 0x52, 0x53, 0xc6, 0x09, 0x74, 0x80, 0x6b, 0xd2, 0xa2, 0x8a, 0x84, 0xa2, 0x9d, 0x18, 0x52,
	0xa3, 0xff, 0x6d, 0xa5, 0x9a, 0x09, 0xf0, 0x20, 0xc7, 0xc6, 0x3b, 0x13, 0x42, 0xef, 0x96, 0xd0,
	0x64, 0x13, 0xf4, 0x3e, 0x1e, 0xed, 0x60, 0x5c, 0x5c, 0xe9, 0x35, 0xfc, 0xa1, 0x04, 0x07, 0xbf,
	0xf2, 0xba, 0xb5, 0x87, 0x1e, 0x3e, 0x6d, 0x2a, 0xd5, 0x7e, 0x56, 0x2f, 0x16, 0x5b, 0xd2, 0x7e,
	0x5e, 0x5d, 0xd9, 0x7a, 0x81, 0xe5, 0xca, 0x1c, 0x39, 0x10, 0x49, 0xc5, 0xe3, 0x4d, 0x40, 0xfd,
	0xbe, 0x84, 0x2e, 0x98, 0xb7, 0xd2, 0x5e, 0xbf, 0x54, 0xe1, 0x6d, 0x38, 0x6b, 0x1c, 0xbf, 0xc5,
	0x54, 0x6f, 0xf4, 0xc9, 0x45, 0x23, 0x38, 0xf9, 0xb7, 0xd7, 0xad, 0xfd, 0xc1, 0xc3, 0xaf, 0x18,
	0x9d, 0xfd, 0xa4, 0x28, 0xf2, 0xe5, 0xa5, 0xe5, 0xb5, 0xf5, 0xe5, 0xc5, 0xda, 0xe6, 0xf2, 0xd2,
	0x1d, 0x5f, 0x14, 0xbe, 0xae, 0x93, 0x2f, 0xac, 0x13, 0x91, 0x80, 0xa4, 0x5a, 0xd8, 0x82, 0x62,
	0xfc, 0x53, 0x69, 0x62, 0xc6, 0x16, 0x88, 0xee, 0x10, 0x0b, 0x68, 0x66, 0x8f, 0x7d, 0x54, 0x2a,
	0x5b, 0x65, 0x28, 0x69, 0xb2, 0x0e, 0x98, 0xd8, 0x6c, 0xb6, 0x81, 0xeb, 0x32, 0xd9, 0x70, 0xba,
	0xa4, 0xf0, 0x6b, 0xd3, 0x73, 0x23, 0xdb, 0xc7, 0x67, 0xf6, 0x93, 0xed, 0x5e, 0x9e, 0x55, 0x0f,
	0x3f, 0x2a, 0xa1, 0xd3, 0x43, 0x89, 0x75, 0x3f, 0x77, 0x14, 0xe8, 0x1c, 0x41, 0xa2, 0x99, 0x07,
	0x7e, 0xe2, 0xe1, 0x99, 0x11, 0x24, 0xfa, 0x4b, 0xff, 0x57, 0x64, 0x9c, 0x0f, 0x46, 0x92, 0xe1,
	0x9e, 0xe1, 0x7f, 0x2b, 0xa1, 0x69, 0xd7, 0x17, 0x9f, 0xb2, 0x72, 0xfd, 0xbc, 0xd4, 0xad, 0x7d,
	0xaf, 0x84, 0xcf, 0x64, 0x9d, 0x71, 0x7f, 0x8e, 0xbd, 0xdc, 0x6f, 0x8f, 0x43, 0x32, 0xec, 0x13,
	0xdc, 0x23, 0x67, 0xfc, 0x11, 0x95, 0xed, 0x3b, 0x25, 0x34, 0xed, 0x9a, 0xe3, 0xc7, 0x2f, 0x6e,
	0xa3, 0x9a, 0xe4, 0x47, 0x5e, 0xb7, 0xf6, 0xae, 0x87, 0xcf, 0x64, 0x5d, 0x72, 0x08, 0xfb, 0x85,
	0x56, 0x39, 0x8a, 0xfe, 0x17, 0xd7, 0x30, 0x9f, 0x58, 0xdf, 0xfe, 0xe1, 0xd9, 0x9f, 0xbd, 0x36,
	0xa8, 0x69, 0x3e, 0x45, 0xc3, 0x97, 0x4d, 0x63, 0xea, 0x3f, 0x29, 0x86, 0xa7, 0xa0, 0x79, 0xda,
	0x3d, 0xf2, 0xf0, 0x79, 0x5b, 0xdb, 0x2d, 0xc2, 0x80, 0xef, 0xc4, 0x62, 0xf8, 0xaf, 0x0e, 0xd4,
	0x78, 0xb7, 0x6d, 0x80, 0x84, 0x84, 0xee, 0xc6, 0x82, 0x46, 0xcf, 0x2f, 0xd9, 0xce, 0xe2, 0xd9,
	0x21, 0x34, 0xb8, 0xa3, 0x17, 0x3e, 0x87, 0x26, 0x98, 0x28, 0x27, 0x54, 0xa9, 0x6d, 0xa6, 0xcb,
	0x6b, 0x37, 0x99, 0xf8, 0xd2, 0x2b, 0x4a, 0x53, 0xd5, 0xea, 0xaf, 0x85, 0xa2, 0x5d, 0x61, 0xa2,
	0xd2, 0x16, 0x11, 0xc4, 0x15, 0x15, 0x6d, 0x57, 0x9a, 0xa2, 0xc2, 0xc4, 0xfb, 0xa5, 0x83, 0x6b,
	0x37, 0x57, 0x44, 0xfd, 0xb0, 0x65, 0xf3, 0xca, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x03, 0x96,
	0x97, 0x21, 0xba, 0x18, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// UsersClient is the client API for Users service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UsersClient interface {
	CreateUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*NewUserResponse, error)
	NewUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*JWT, error)
	Verify(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Boolean, error)
	ResendVerificationEmail(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Boolean, error)
	GetUser(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetUserResponse, error)
	Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JWT, error)
	ResetPassword(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*empty.Empty, error)
	SendPasswordResetLink(ctx context.Context, in *Username, opts ...grpc.CallOption) (*empty.Empty, error)
	ChangePassword(ctx context.Context, in *PasswordResetInput, opts ...grpc.CallOption) (*empty.Empty, error)
	GetProjectsForUserQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Users_GetProjectsForUserQueryDeprecatedClient, error)
	GetProjectsQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Users_GetProjectsQueryDeprecatedClient, error)
	GetProjectsForUserQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (Users_GetProjectsForUserQueryClient, error)
	GetProjectsQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (Users_GetProjectsQueryClient, error)
	GetProjectByUuid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Project, error)
	GetProjectAndTemplateByShortCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ProjectByShortCodeResult, error)
	GetProjectsForUser(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsForUserClient, error)
	GetProjects(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsClient, error)
}

type usersClient struct {
	cc grpc.ClientConnInterface
}

func NewUsersClient(cc grpc.ClientConnInterface) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) CreateUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*NewUserResponse, error) {
	out := new(NewUserResponse)
	err := c.cc.Invoke(ctx, "/io.Users/createUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) NewUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*JWT, error) {
	out := new(JWT)
	err := c.cc.Invoke(ctx, "/io.Users/newUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Verify(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Boolean, error) {
	out := new(Boolean)
	err := c.cc.Invoke(ctx, "/io.Users/verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ResendVerificationEmail(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Boolean, error) {
	out := new(Boolean)
	err := c.cc.Invoke(ctx, "/io.Users/resendVerificationEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetUser(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetUserResponse, error) {
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, "/io.Users/getUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JWT, error) {
	out := new(JWT)
	err := c.cc.Invoke(ctx, "/io.Users/login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ResetPassword(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Users/resetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) SendPasswordResetLink(ctx context.Context, in *Username, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Users/sendPasswordResetLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ChangePassword(ctx context.Context, in *PasswordResetInput, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Users/changePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectsForUserQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Users_GetProjectsForUserQueryDeprecatedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[0], "/io.Users/getProjectsForUserQueryDeprecated", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsForUserQueryDeprecatedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsForUserQueryDeprecatedClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsForUserQueryDeprecatedClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsForUserQueryDeprecatedClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usersClient) GetProjectsQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Users_GetProjectsQueryDeprecatedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[1], "/io.Users/getProjectsQueryDeprecated", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsQueryDeprecatedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsQueryDeprecatedClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsQueryDeprecatedClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsQueryDeprecatedClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usersClient) GetProjectsForUserQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (Users_GetProjectsForUserQueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[2], "/io.Users/getProjectsForUserQuery", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsForUserQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsForUserQueryClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsForUserQueryClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsForUserQueryClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usersClient) GetProjectsQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (Users_GetProjectsQueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[3], "/io.Users/getProjectsQuery", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsQueryClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsQueryClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsQueryClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usersClient) GetProjectByUuid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Project, error) {
	out := new(Project)
	err := c.cc.Invoke(ctx, "/io.Users/getProjectByUuid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectAndTemplateByShortCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ProjectByShortCodeResult, error) {
	out := new(ProjectByShortCodeResult)
	err := c.cc.Invoke(ctx, "/io.Users/getProjectAndTemplateByShortCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectsForUser(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsForUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[4], "/io.Users/getProjectsForUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsForUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsForUserClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsForUserClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsForUserClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usersClient) GetProjects(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[5], "/io.Users/getProjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UsersServer is the server API for Users service.
type UsersServer interface {
	CreateUser(context.Context, *NewUser) (*NewUserResponse, error)
	NewUser(context.Context, *NewUser) (*JWT, error)
	Verify(context.Context, *Id) (*Boolean, error)
	ResendVerificationEmail(context.Context, *empty.Empty) (*Boolean, error)
	GetUser(context.Context, *empty.Empty) (*GetUserResponse, error)
	Login(context.Context, *Credentials) (*JWT, error)
	ResetPassword(context.Context, *Credentials) (*empty.Empty, error)
	SendPasswordResetLink(context.Context, *Username) (*empty.Empty, error)
	ChangePassword(context.Context, *PasswordResetInput) (*empty.Empty, error)
	GetProjectsForUserQueryDeprecated(*Pagination, Users_GetProjectsForUserQueryDeprecatedServer) error
	GetProjectsQueryDeprecated(*Pagination, Users_GetProjectsQueryDeprecatedServer) error
	GetProjectsForUserQuery(*Filters, Users_GetProjectsForUserQueryServer) error
	GetProjectsQuery(*Filters, Users_GetProjectsQueryServer) error
	GetProjectByUuid(context.Context, *Id) (*Project, error)
	GetProjectAndTemplateByShortCode(context.Context, *Id) (*ProjectByShortCodeResult, error)
	GetProjectsForUser(*ProjectStatusFilter, Users_GetProjectsForUserServer) error
	GetProjects(*ProjectStatusFilter, Users_GetProjectsServer) error
}

// UnimplementedUsersServer can be embedded to have forward compatible implementations.
type UnimplementedUsersServer struct {
}

func (*UnimplementedUsersServer) CreateUser(ctx context.Context, req *NewUser) (*NewUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (*UnimplementedUsersServer) NewUser(ctx context.Context, req *NewUser) (*JWT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewUser not implemented")
}
func (*UnimplementedUsersServer) Verify(ctx context.Context, req *Id) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (*UnimplementedUsersServer) ResendVerificationEmail(ctx context.Context, req *empty.Empty) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResendVerificationEmail not implemented")
}
func (*UnimplementedUsersServer) GetUser(ctx context.Context, req *empty.Empty) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (*UnimplementedUsersServer) Login(ctx context.Context, req *Credentials) (*JWT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (*UnimplementedUsersServer) ResetPassword(ctx context.Context, req *Credentials) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (*UnimplementedUsersServer) SendPasswordResetLink(ctx context.Context, req *Username) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPasswordResetLink not implemented")
}
func (*UnimplementedUsersServer) ChangePassword(ctx context.Context, req *PasswordResetInput) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (*UnimplementedUsersServer) GetProjectsForUserQueryDeprecated(req *Pagination, srv Users_GetProjectsForUserQueryDeprecatedServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsForUserQueryDeprecated not implemented")
}
func (*UnimplementedUsersServer) GetProjectsQueryDeprecated(req *Pagination, srv Users_GetProjectsQueryDeprecatedServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsQueryDeprecated not implemented")
}
func (*UnimplementedUsersServer) GetProjectsForUserQuery(req *Filters, srv Users_GetProjectsForUserQueryServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsForUserQuery not implemented")
}
func (*UnimplementedUsersServer) GetProjectsQuery(req *Filters, srv Users_GetProjectsQueryServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsQuery not implemented")
}
func (*UnimplementedUsersServer) GetProjectByUuid(ctx context.Context, req *Id) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectByUuid not implemented")
}
func (*UnimplementedUsersServer) GetProjectAndTemplateByShortCode(ctx context.Context, req *Id) (*ProjectByShortCodeResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectAndTemplateByShortCode not implemented")
}
func (*UnimplementedUsersServer) GetProjectsForUser(req *ProjectStatusFilter, srv Users_GetProjectsForUserServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsForUser not implemented")
}
func (*UnimplementedUsersServer) GetProjects(req *ProjectStatusFilter, srv Users_GetProjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}

func RegisterUsersServer(s *grpc.Server, srv UsersServer) {
	s.RegisterService(&_Users_serviceDesc, srv)
}

func _Users_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateUser(ctx, req.(*NewUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_NewUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).NewUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/NewUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).NewUser(ctx, req.(*NewUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).Verify(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ResendVerificationEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ResendVerificationEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/ResendVerificationEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ResendVerificationEmail(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetUser(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).Login(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/ResetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ResetPassword(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_SendPasswordResetLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Username)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).SendPasswordResetLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/SendPasswordResetLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).SendPasswordResetLink(ctx, req.(*Username))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordResetInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/ChangePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ChangePassword(ctx, req.(*PasswordResetInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectsForUserQueryDeprecated_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsForUserQueryDeprecated(m, &usersGetProjectsForUserQueryDeprecatedServer{stream})
}

type Users_GetProjectsForUserQueryDeprecatedServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsForUserQueryDeprecatedServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsForUserQueryDeprecatedServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _Users_GetProjectsQueryDeprecated_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsQueryDeprecated(m, &usersGetProjectsQueryDeprecatedServer{stream})
}

type Users_GetProjectsQueryDeprecatedServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsQueryDeprecatedServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsQueryDeprecatedServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _Users_GetProjectsForUserQuery_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filters)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsForUserQuery(m, &usersGetProjectsForUserQueryServer{stream})
}

type Users_GetProjectsForUserQueryServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsForUserQueryServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsForUserQueryServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _Users_GetProjectsQuery_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filters)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsQuery(m, &usersGetProjectsQueryServer{stream})
}

type Users_GetProjectsQueryServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsQueryServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsQueryServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _Users_GetProjectByUuid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetProjectByUuid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/GetProjectByUuid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetProjectByUuid(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectAndTemplateByShortCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetProjectAndTemplateByShortCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/GetProjectAndTemplateByShortCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetProjectAndTemplateByShortCode(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectsForUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectStatusFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsForUser(m, &usersGetProjectsForUserServer{stream})
}

type Users_GetProjectsForUserServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsForUserServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsForUserServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _Users_GetProjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectStatusFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjects(m, &usersGetProjectsServer{stream})
}

type Users_GetProjectsServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

var _Users_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createUser",
			Handler:    _Users_CreateUser_Handler,
		},
		{
			MethodName: "newUser",
			Handler:    _Users_NewUser_Handler,
		},
		{
			MethodName: "verify",
			Handler:    _Users_Verify_Handler,
		},
		{
			MethodName: "resendVerificationEmail",
			Handler:    _Users_ResendVerificationEmail_Handler,
		},
		{
			MethodName: "getUser",
			Handler:    _Users_GetUser_Handler,
		},
		{
			MethodName: "login",
			Handler:    _Users_Login_Handler,
		},
		{
			MethodName: "resetPassword",
			Handler:    _Users_ResetPassword_Handler,
		},
		{
			MethodName: "sendPasswordResetLink",
			Handler:    _Users_SendPasswordResetLink_Handler,
		},
		{
			MethodName: "changePassword",
			Handler:    _Users_ChangePassword_Handler,
		},
		{
			MethodName: "getProjectByUuid",
			Handler:    _Users_GetProjectByUuid_Handler,
		},
		{
			MethodName: "getProjectAndTemplateByShortCode",
			Handler:    _Users_GetProjectAndTemplateByShortCode_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getProjectsForUserQueryDeprecated",
			Handler:       _Users_GetProjectsForUserQueryDeprecated_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsQueryDeprecated",
			Handler:       _Users_GetProjectsQueryDeprecated_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsForUserQuery",
			Handler:       _Users_GetProjectsForUserQuery_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsQuery",
			Handler:       _Users_GetProjectsQuery_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsForUser",
			Handler:       _Users_GetProjectsForUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjects",
			Handler:       _Users_GetProjects_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc_others.proto",
}

// MessagesClient is the client API for Messages service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MessagesClient interface {
	SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Id, error)
	GetMessages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Messages_GetMessagesClient, error)
}

type messagesClient struct {
	cc grpc.ClientConnInterface
}

func NewMessagesClient(cc grpc.ClientConnInterface) MessagesClient {
	return &messagesClient{cc}
}

func (c *messagesClient) SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Messages/sendMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagesClient) GetMessages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Messages_GetMessagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Messages_serviceDesc.Streams[0], "/io.Messages/getMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &messagesGetMessagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Messages_GetMessagesClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type messagesGetMessagesClient struct {
	grpc.ClientStream
}

func (x *messagesGetMessagesClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MessagesServer is the server API for Messages service.
type MessagesServer interface {
	SendMessage(context.Context, *Message) (*Id, error)
	GetMessages(*Pagination, Messages_GetMessagesServer) error
}

// UnimplementedMessagesServer can be embedded to have forward compatible implementations.
type UnimplementedMessagesServer struct {
}

func (*UnimplementedMessagesServer) SendMessage(ctx context.Context, req *Message) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (*UnimplementedMessagesServer) GetMessages(req *Pagination, srv Messages_GetMessagesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetMessages not implemented")
}

func RegisterMessagesServer(s *grpc.Server, srv MessagesServer) {
	s.RegisterService(&_Messages_serviceDesc, srv)
}

func _Messages_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagesServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Messages/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagesServer).SendMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Messages_GetMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MessagesServer).GetMessages(m, &messagesGetMessagesServer{stream})
}

type Messages_GetMessagesServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type messagesGetMessagesServer struct {
	grpc.ServerStream
}

func (x *messagesGetMessagesServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

var _Messages_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Messages",
	HandlerType: (*MessagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "sendMessage",
			Handler:    _Messages_SendMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getMessages",
			Handler:       _Messages_GetMessages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc_others.proto",
}

// DistributionClient is the client API for Distribution service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DistributionClient interface {
	SendWelcomeEmail(ctx context.Context, in *EmailDistributionRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type distributionClient struct {
	cc grpc.ClientConnInterface
}

func NewDistributionClient(cc grpc.ClientConnInterface) DistributionClient {
	return &distributionClient{cc}
}

func (c *distributionClient) SendWelcomeEmail(ctx context.Context, in *EmailDistributionRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Distribution/sendWelcomeEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DistributionServer is the server API for Distribution service.
type DistributionServer interface {
	SendWelcomeEmail(context.Context, *EmailDistributionRequest) (*empty.Empty, error)
}

// UnimplementedDistributionServer can be embedded to have forward compatible implementations.
type UnimplementedDistributionServer struct {
}

func (*UnimplementedDistributionServer) SendWelcomeEmail(ctx context.Context, req *EmailDistributionRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendWelcomeEmail not implemented")
}

func RegisterDistributionServer(s *grpc.Server, srv DistributionServer) {
	s.RegisterService(&_Distribution_serviceDesc, srv)
}

func _Distribution_SendWelcomeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributionServer).SendWelcomeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Distribution/SendWelcomeEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributionServer).SendWelcomeEmail(ctx, req.(*EmailDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Distribution_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Distribution",
	HandlerType: (*DistributionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "sendWelcomeEmail",
			Handler:    _Distribution_SendWelcomeEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "io/core/a_rpc_others.proto",
}

// JobsClient is the client API for Jobs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JobsClient interface {
	ImportCsv(ctx context.Context, in *CsvImportRequest, opts ...grpc.CallOption) (*Id, error)
	GetJobs(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Jobs_GetJobsClient, error)
	GetJob(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Job, error)
}

type jobsClient struct {
	cc grpc.ClientConnInterface
}

func NewJobsClient(cc grpc.ClientConnInterface) JobsClient {
	return &jobsClient{cc}
}

func (c *jobsClient) ImportCsv(ctx context.Context, in *CsvImportRequest, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Jobs/importCsv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsClient) GetJobs(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Jobs_GetJobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Jobs_serviceDesc.Streams[0], "/io.Jobs/getJobs", opts...)
	if err != nil {
		return nil, err
	}
	x := &jobsGetJobsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Jobs_GetJobsClient interface {
	Recv() (*Job, error)
	grpc.ClientStream
}

type jobsGetJobsClient struct {
	grpc.ClientStream
}

func (x *jobsGetJobsClient) Recv() (*Job, error) {
	m := new(Job)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *jobsClient) GetJob(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := c.cc.Invoke(ctx, "/io.Jobs/getJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobsServer is the server API for Jobs service.
type JobsServer interface {
	ImportCsv(context.Context, *CsvImportRequest) (*Id, error)
	GetJobs(*Pagination, Jobs_GetJobsServer) error
	GetJob(context.Context, *Id) (*Job, error)
}

// UnimplementedJobsServer can be embedded to have forward compatible implementations.
type UnimplementedJobsServer struct {
}

func (*UnimplementedJobsServer) ImportCsv(ctx context.Context, req *CsvImportRequest) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportCsv not implemented")
}
func (*UnimplementedJobsServer) GetJobs(req *Pagination, srv Jobs_GetJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetJobs not implemented")
}
func (*UnimplementedJobsServer) GetJob(ctx context.Context, req *Id) (*Job, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}

func RegisterJobsServer(s *grpc.Server, srv JobsServer) {
	s.RegisterService(&_Jobs_serviceDesc, srv)
}

func _Jobs_ImportCsv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CsvImportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServer).ImportCsv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Jobs/ImportCsv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServer).ImportCsv(ctx, req.(*CsvImportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jobs_GetJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobsServer).GetJobs(m, &jobsGetJobsServer{stream})
}

type Jobs_GetJobsServer interface {
	Send(*Job) error
	grpc.ServerStream
}

type jobsGetJobsServer struct {
	grpc.ServerStream
}

func (x *jobsGetJobsServer) Send(m *Job) error {
	return x.ServerStream.SendMsg(m)
}

func _Jobs_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Jobs/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServer).GetJob(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _Jobs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Jobs",
	HandlerType: (*JobsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "importCsv",
			Handler:    _Jobs_ImportCsv_Handler,
		},
		{
			MethodName: "getJob",
			Handler:    _Jobs_GetJob_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getJobs",
			Handler:       _Jobs_GetJobs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc_others.proto",
}

// IntegrationsClient is the client API for Integrations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IntegrationsClient interface {
	CreateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error)
	GetIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*IntegrationConfigs, error)
	UpdateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error)
	DeleteIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*empty.Empty, error)
	CreateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error)
	GetSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*SinkSubscription, error)
	ListSinkSubscriptionsDeprecated(ctx context.Context, in *ListRequestDeprecated, opts ...grpc.CallOption) (Integrations_ListSinkSubscriptionsDeprecatedClient, error)
	ListSinkSubscriptions(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (Integrations_ListSinkSubscriptionsClient, error)
	UpdateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error)
	DeleteSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetSampleSubscriptionEvent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SinkSubscription, error)
}

type integrationsClient struct {
	cc grpc.ClientConnInterface
}

func NewIntegrationsClient(cc grpc.ClientConnInterface) IntegrationsClient {
	return &integrationsClient{cc}
}

func (c *integrationsClient) CreateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Integrations/createIntegrations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) GetIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*IntegrationConfigs, error) {
	out := new(IntegrationConfigs)
	err := c.cc.Invoke(ctx, "/io.Integrations/getIntegrations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) UpdateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Integrations/updateIntegrations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) DeleteIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Integrations/deleteIntegrations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) CreateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Integrations/createSinkSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) GetSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*SinkSubscription, error) {
	out := new(SinkSubscription)
	err := c.cc.Invoke(ctx, "/io.Integrations/getSinkSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) ListSinkSubscriptionsDeprecated(ctx context.Context, in *ListRequestDeprecated, opts ...grpc.CallOption) (Integrations_ListSinkSubscriptionsDeprecatedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Integrations_serviceDesc.Streams[0], "/io.Integrations/listSinkSubscriptionsDeprecated", opts...)
	if err != nil {
		return nil, err
	}
	x := &integrationsListSinkSubscriptionsDeprecatedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Integrations_ListSinkSubscriptionsDeprecatedClient interface {
	Recv() (*SinkSubscription, error)
	grpc.ClientStream
}

type integrationsListSinkSubscriptionsDeprecatedClient struct {
	grpc.ClientStream
}

func (x *integrationsListSinkSubscriptionsDeprecatedClient) Recv() (*SinkSubscription, error) {
	m := new(SinkSubscription)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *integrationsClient) ListSinkSubscriptions(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (Integrations_ListSinkSubscriptionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Integrations_serviceDesc.Streams[1], "/io.Integrations/listSinkSubscriptions", opts...)
	if err != nil {
		return nil, err
	}
	x := &integrationsListSinkSubscriptionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Integrations_ListSinkSubscriptionsClient interface {
	Recv() (*SinkSubscription, error)
	grpc.ClientStream
}

type integrationsListSinkSubscriptionsClient struct {
	grpc.ClientStream
}

func (x *integrationsListSinkSubscriptionsClient) Recv() (*SinkSubscription, error) {
	m := new(SinkSubscription)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *integrationsClient) UpdateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Integrations/updateSinkSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) DeleteSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Integrations/deleteSinkSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) GetSampleSubscriptionEvent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SinkSubscription, error) {
	out := new(SinkSubscription)
	err := c.cc.Invoke(ctx, "/io.Integrations/getSampleSubscriptionEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntegrationsServer is the server API for Integrations service.
type IntegrationsServer interface {
	CreateIntegrations(context.Context, *IntegrationConfigs) (*Id, error)
	GetIntegrations(context.Context, *ProtocolIdInput) (*IntegrationConfigs, error)
	UpdateIntegrations(context.Context, *IntegrationConfigs) (*Id, error)
	DeleteIntegrations(context.Context, *ProtocolIdInput) (*empty.Empty, error)
	CreateSinkSubscription(context.Context, *SinkSubscription) (*Id, error)
	GetSinkSubscription(context.Context, *SubscriptionRequest) (*SinkSubscription, error)
	ListSinkSubscriptionsDeprecated(*ListRequestDeprecated, Integrations_ListSinkSubscriptionsDeprecatedServer) error
	ListSinkSubscriptions(*ListRequest, Integrations_ListSinkSubscriptionsServer) error
	UpdateSinkSubscription(context.Context, *SinkSubscription) (*Id, error)
	DeleteSinkSubscription(context.Context, *SubscriptionRequest) (*empty.Empty, error)
	GetSampleSubscriptionEvent(context.Context, *Id) (*SinkSubscription, error)
}

// UnimplementedIntegrationsServer can be embedded to have forward compatible implementations.
type UnimplementedIntegrationsServer struct {
}

func (*UnimplementedIntegrationsServer) CreateIntegrations(ctx context.Context, req *IntegrationConfigs) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIntegrations not implemented")
}
func (*UnimplementedIntegrationsServer) GetIntegrations(ctx context.Context, req *ProtocolIdInput) (*IntegrationConfigs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegrations not implemented")
}
func (*UnimplementedIntegrationsServer) UpdateIntegrations(ctx context.Context, req *IntegrationConfigs) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIntegrations not implemented")
}
func (*UnimplementedIntegrationsServer) DeleteIntegrations(ctx context.Context, req *ProtocolIdInput) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIntegrations not implemented")
}
func (*UnimplementedIntegrationsServer) CreateSinkSubscription(ctx context.Context, req *SinkSubscription) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSinkSubscription not implemented")
}
func (*UnimplementedIntegrationsServer) GetSinkSubscription(ctx context.Context, req *SubscriptionRequest) (*SinkSubscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSinkSubscription not implemented")
}
func (*UnimplementedIntegrationsServer) ListSinkSubscriptionsDeprecated(req *ListRequestDeprecated, srv Integrations_ListSinkSubscriptionsDeprecatedServer) error {
	return status.Errorf(codes.Unimplemented, "method ListSinkSubscriptionsDeprecated not implemented")
}
func (*UnimplementedIntegrationsServer) ListSinkSubscriptions(req *ListRequest, srv Integrations_ListSinkSubscriptionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListSinkSubscriptions not implemented")
}
func (*UnimplementedIntegrationsServer) UpdateSinkSubscription(ctx context.Context, req *SinkSubscription) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSinkSubscription not implemented")
}
func (*UnimplementedIntegrationsServer) DeleteSinkSubscription(ctx context.Context, req *SubscriptionRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSinkSubscription not implemented")
}
func (*UnimplementedIntegrationsServer) GetSampleSubscriptionEvent(ctx context.Context, req *Id) (*SinkSubscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSampleSubscriptionEvent not implemented")
}

func RegisterIntegrationsServer(s *grpc.Server, srv IntegrationsServer) {
	s.RegisterService(&_Integrations_serviceDesc, srv)
}

func _Integrations_CreateIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegrationConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).CreateIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/CreateIntegrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).CreateIntegrations(ctx, req.(*IntegrationConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_GetIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtocolIdInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).GetIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/GetIntegrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).GetIntegrations(ctx, req.(*ProtocolIdInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_UpdateIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegrationConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).UpdateIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/UpdateIntegrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).UpdateIntegrations(ctx, req.(*IntegrationConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_DeleteIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtocolIdInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).DeleteIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/DeleteIntegrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).DeleteIntegrations(ctx, req.(*ProtocolIdInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_CreateSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SinkSubscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).CreateSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/CreateSinkSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).CreateSinkSubscription(ctx, req.(*SinkSubscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_GetSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).GetSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/GetSinkSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).GetSinkSubscription(ctx, req.(*SubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_ListSinkSubscriptionsDeprecated_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRequestDeprecated)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IntegrationsServer).ListSinkSubscriptionsDeprecated(m, &integrationsListSinkSubscriptionsDeprecatedServer{stream})
}

type Integrations_ListSinkSubscriptionsDeprecatedServer interface {
	Send(*SinkSubscription) error
	grpc.ServerStream
}

type integrationsListSinkSubscriptionsDeprecatedServer struct {
	grpc.ServerStream
}

func (x *integrationsListSinkSubscriptionsDeprecatedServer) Send(m *SinkSubscription) error {
	return x.ServerStream.SendMsg(m)
}

func _Integrations_ListSinkSubscriptions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IntegrationsServer).ListSinkSubscriptions(m, &integrationsListSinkSubscriptionsServer{stream})
}

type Integrations_ListSinkSubscriptionsServer interface {
	Send(*SinkSubscription) error
	grpc.ServerStream
}

type integrationsListSinkSubscriptionsServer struct {
	grpc.ServerStream
}

func (x *integrationsListSinkSubscriptionsServer) Send(m *SinkSubscription) error {
	return x.ServerStream.SendMsg(m)
}

func _Integrations_UpdateSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SinkSubscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).UpdateSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/UpdateSinkSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).UpdateSinkSubscription(ctx, req.(*SinkSubscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_DeleteSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).DeleteSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/DeleteSinkSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).DeleteSinkSubscription(ctx, req.(*SubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_GetSampleSubscriptionEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).GetSampleSubscriptionEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Integrations/GetSampleSubscriptionEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).GetSampleSubscriptionEvent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _Integrations_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Integrations",
	HandlerType: (*IntegrationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createIntegrations",
			Handler:    _Integrations_CreateIntegrations_Handler,
		},
		{
			MethodName: "getIntegrations",
			Handler:    _Integrations_GetIntegrations_Handler,
		},
		{
			MethodName: "updateIntegrations",
			Handler:    _Integrations_UpdateIntegrations_Handler,
		},
		{
			MethodName: "deleteIntegrations",
			Handler:    _Integrations_DeleteIntegrations_Handler,
		},
		{
			MethodName: "createSinkSubscription",
			Handler:    _Integrations_CreateSinkSubscription_Handler,
		},
		{
			MethodName: "getSinkSubscription",
			Handler:    _Integrations_GetSinkSubscription_Handler,
		},
		{
			MethodName: "updateSinkSubscription",
			Handler:    _Integrations_UpdateSinkSubscription_Handler,
		},
		{
			MethodName: "deleteSinkSubscription",
			Handler:    _Integrations_DeleteSinkSubscription_Handler,
		},
		{
			MethodName: "getSampleSubscriptionEvent",
			Handler:    _Integrations_GetSampleSubscriptionEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "listSinkSubscriptionsDeprecated",
			Handler:       _Integrations_ListSinkSubscriptionsDeprecated_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listSinkSubscriptions",
			Handler:       _Integrations_ListSinkSubscriptions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc_others.proto",
}
