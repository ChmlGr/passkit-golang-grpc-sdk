// Code generated by protoc-gen-go. DO NOT EDIT.
// source: io/common/job.proto

package io

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type JobStatus int32

const (
	JobStatus_JOB_SCHEDULED             JobStatus = 0
	JobStatus_JOB_RUNNING               JobStatus = 1
	JobStatus_JOB_PAUSED                JobStatus = 2
	JobStatus_JOB_COMPLETED             JobStatus = 3
	JobStatus_JOB_COMPLETED_WITH_ERRORS JobStatus = 4
)

var JobStatus_name = map[int32]string{
	0: "JOB_SCHEDULED",
	1: "JOB_RUNNING",
	2: "JOB_PAUSED",
	3: "JOB_COMPLETED",
	4: "JOB_COMPLETED_WITH_ERRORS",
}

var JobStatus_value = map[string]int32{
	"JOB_SCHEDULED":             0,
	"JOB_RUNNING":               1,
	"JOB_PAUSED":                2,
	"JOB_COMPLETED":             3,
	"JOB_COMPLETED_WITH_ERRORS": 4,
}

func (x JobStatus) String() string {
	return proto.EnumName(JobStatus_name, int32(x))
}

func (JobStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c98cc3a51c7e8bfb, []int{0}
}

type JobType int32

const (
	JobType_JOB_CSV_IMPORT JobType = 0
	JobType_JOB_CSV_EXPORT JobType = 1
)

var JobType_name = map[int32]string{
	0: "JOB_CSV_IMPORT",
	1: "JOB_CSV_EXPORT",
}

var JobType_value = map[string]int32{
	"JOB_CSV_IMPORT": 0,
	"JOB_CSV_EXPORT": 1,
}

func (x JobType) String() string {
	return proto.EnumName(JobType_name, int32(x))
}

func (JobType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c98cc3a51c7e8bfb, []int{1}
}

type Job struct {
	// Auto generated 22 char identifier.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The username of the user that requested the job.
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// The protocol of the associated resource.
	Protocol PassProtocol `protobuf:"varint,3,opt,name=protocol,proto3,enum=io.PassProtocol" json:"protocol,omitempty"`
	// The status of the job.
	Status JobStatus `protobuf:"varint,4,opt,name=status,proto3,enum=io.JobStatus" json:"status,omitempty"`
	// The type of job running.
	Type JobType `protobuf:"varint,5,opt,name=type,proto3,enum=io.JobType" json:"type,omitempty"`
	// Defines the recurrence schedule of the job.
	Schedule *Schedule `protobuf:"bytes,6,opt,name=schedule,proto3" json:"schedule,omitempty"`
	// The date the job was created in the PassKit system.
	Created *timestamp.Timestamp `protobuf:"bytes,7,opt,name=created,proto3" json:"created,omitempty"`
	// The date the job was updated in the PassKit system.
	Updated *timestamp.Timestamp `protobuf:"bytes,8,opt,name=updated,proto3" json:"updated,omitempty"`
	// The date the job will run for the first time in the PassKit system.
	FirstRun *timestamp.Timestamp `protobuf:"bytes,9,opt,name=firstRun,proto3" json:"firstRun,omitempty"`
	// The date the job will run for the last time in the PassKit system.
	FinalRun *timestamp.Timestamp `protobuf:"bytes,10,opt,name=finalRun,proto3" json:"finalRun,omitempty"`
	// The date the job will run next in the PassKit system.
	NextRun *timestamp.Timestamp `protobuf:"bytes,11,opt,name=nextRun,proto3" json:"nextRun,omitempty"`
	// The date the job was last run in the PassKit system.
	LastRun              *timestamp.Timestamp `protobuf:"bytes,12,opt,name=lastRun,proto3" json:"lastRun,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_c98cc3a51c7e8bfb, []int{0}
}

func (m *Job) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Job.Unmarshal(m, b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Job.Marshal(b, m, deterministic)
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return xxx_messageInfo_Job.Size(m)
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Job) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Job) GetProtocol() PassProtocol {
	if m != nil {
		return m.Protocol
	}
	return PassProtocol_RAW_PROTOCOL
}

func (m *Job) GetStatus() JobStatus {
	if m != nil {
		return m.Status
	}
	return JobStatus_JOB_SCHEDULED
}

func (m *Job) GetType() JobType {
	if m != nil {
		return m.Type
	}
	return JobType_JOB_CSV_IMPORT
}

func (m *Job) GetSchedule() *Schedule {
	if m != nil {
		return m.Schedule
	}
	return nil
}

func (m *Job) GetCreated() *timestamp.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Job) GetUpdated() *timestamp.Timestamp {
	if m != nil {
		return m.Updated
	}
	return nil
}

func (m *Job) GetFirstRun() *timestamp.Timestamp {
	if m != nil {
		return m.FirstRun
	}
	return nil
}

func (m *Job) GetFinalRun() *timestamp.Timestamp {
	if m != nil {
		return m.FinalRun
	}
	return nil
}

func (m *Job) GetNextRun() *timestamp.Timestamp {
	if m != nil {
		return m.NextRun
	}
	return nil
}

func (m *Job) GetLastRun() *timestamp.Timestamp {
	if m != nil {
		return m.LastRun
	}
	return nil
}

type CompletedJob struct {
	// Auto generated 22 char identifier.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The company id of the user that requested the job.
	Cid string `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
	// The user id of the user that requested the job.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// The protocol of the associated resource.
	Protocol PassProtocol `protobuf:"varint,4,opt,name=protocol,proto3,enum=io.PassProtocol" json:"protocol,omitempty"`
	// The type of job completed.
	Type JobType `protobuf:"varint,5,opt,name=type,proto3,enum=io.JobType" json:"type,omitempty"`
	// The status of the completed Job.
	Status JobStatus `protobuf:"varint,6,opt,name=status,proto3,enum=io.JobStatus" json:"status,omitempty"`
	// Any details about the Job that are relevant to the user.
	Details string `protobuf:"bytes,7,opt,name=details,proto3" json:"details,omitempty"`
	// The date the job was completed in the PassKit system.
	Completed *timestamp.Timestamp `protobuf:"bytes,8,opt,name=completed,proto3" json:"completed,omitempty"`
	// Specific outputs related to the type f Job that was run.
	//
	// Types that are valid to be assigned to CompletedJobOutput:
	//	*CompletedJob_CompletedCsvImport
	CompletedJobOutput   isCompletedJob_CompletedJobOutput `protobuf_oneof:"CompletedJobOutput"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *CompletedJob) Reset()         { *m = CompletedJob{} }
func (m *CompletedJob) String() string { return proto.CompactTextString(m) }
func (*CompletedJob) ProtoMessage()    {}
func (*CompletedJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_c98cc3a51c7e8bfb, []int{1}
}

func (m *CompletedJob) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompletedJob.Unmarshal(m, b)
}
func (m *CompletedJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompletedJob.Marshal(b, m, deterministic)
}
func (m *CompletedJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompletedJob.Merge(m, src)
}
func (m *CompletedJob) XXX_Size() int {
	return xxx_messageInfo_CompletedJob.Size(m)
}
func (m *CompletedJob) XXX_DiscardUnknown() {
	xxx_messageInfo_CompletedJob.DiscardUnknown(m)
}

var xxx_messageInfo_CompletedJob proto.InternalMessageInfo

func (m *CompletedJob) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CompletedJob) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *CompletedJob) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *CompletedJob) GetProtocol() PassProtocol {
	if m != nil {
		return m.Protocol
	}
	return PassProtocol_RAW_PROTOCOL
}

func (m *CompletedJob) GetType() JobType {
	if m != nil {
		return m.Type
	}
	return JobType_JOB_CSV_IMPORT
}

func (m *CompletedJob) GetStatus() JobStatus {
	if m != nil {
		return m.Status
	}
	return JobStatus_JOB_SCHEDULED
}

func (m *CompletedJob) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

func (m *CompletedJob) GetCompleted() *timestamp.Timestamp {
	if m != nil {
		return m.Completed
	}
	return nil
}

type isCompletedJob_CompletedJobOutput interface {
	isCompletedJob_CompletedJobOutput()
}

type CompletedJob_CompletedCsvImport struct {
	CompletedCsvImport *CompletedCsvImport `protobuf:"bytes,9,opt,name=completedCsvImport,proto3,oneof"`
}

func (*CompletedJob_CompletedCsvImport) isCompletedJob_CompletedJobOutput() {}

func (m *CompletedJob) GetCompletedJobOutput() isCompletedJob_CompletedJobOutput {
	if m != nil {
		return m.CompletedJobOutput
	}
	return nil
}

func (m *CompletedJob) GetCompletedCsvImport() *CompletedCsvImport {
	if x, ok := m.GetCompletedJobOutput().(*CompletedJob_CompletedCsvImport); ok {
		return x.CompletedCsvImport
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CompletedJob) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CompletedJob_CompletedCsvImport)(nil),
	}
}

type CompletedCsvImport struct {
	FileUrl              string   `protobuf:"bytes,1,opt,name=fileUrl,proto3" json:"fileUrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompletedCsvImport) Reset()         { *m = CompletedCsvImport{} }
func (m *CompletedCsvImport) String() string { return proto.CompactTextString(m) }
func (*CompletedCsvImport) ProtoMessage()    {}
func (*CompletedCsvImport) Descriptor() ([]byte, []int) {
	return fileDescriptor_c98cc3a51c7e8bfb, []int{2}
}

func (m *CompletedCsvImport) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompletedCsvImport.Unmarshal(m, b)
}
func (m *CompletedCsvImport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompletedCsvImport.Marshal(b, m, deterministic)
}
func (m *CompletedCsvImport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompletedCsvImport.Merge(m, src)
}
func (m *CompletedCsvImport) XXX_Size() int {
	return xxx_messageInfo_CompletedCsvImport.Size(m)
}
func (m *CompletedCsvImport) XXX_DiscardUnknown() {
	xxx_messageInfo_CompletedCsvImport.DiscardUnknown(m)
}

var xxx_messageInfo_CompletedCsvImport proto.InternalMessageInfo

func (m *CompletedCsvImport) GetFileUrl() string {
	if m != nil {
		return m.FileUrl
	}
	return ""
}

type Schedule struct {
	// Defines the recurrence of the job in cronTab format.
	CronTabSchedule string `protobuf:"bytes,1,opt,name=cronTabSchedule,proto3" json:"cronTabSchedule,omitempty"`
	// If the job repeats.
	Repeating bool   `protobuf:"varint,2,opt,name=repeating,proto3" json:"repeating,omitempty"`
	Timezone  string `protobuf:"bytes,3,opt,name=timezone,proto3" json:"timezone,omitempty"`
	// The time the job should start.
	StartTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Optional time when the job will stop.
	RunUntil             *timestamp.Timestamp `protobuf:"bytes,5,opt,name=runUntil,proto3" json:"runUntil,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Schedule) Reset()         { *m = Schedule{} }
func (m *Schedule) String() string { return proto.CompactTextString(m) }
func (*Schedule) ProtoMessage()    {}
func (*Schedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_c98cc3a51c7e8bfb, []int{3}
}

func (m *Schedule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Schedule.Unmarshal(m, b)
}
func (m *Schedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Schedule.Marshal(b, m, deterministic)
}
func (m *Schedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedule.Merge(m, src)
}
func (m *Schedule) XXX_Size() int {
	return xxx_messageInfo_Schedule.Size(m)
}
func (m *Schedule) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedule.DiscardUnknown(m)
}

var xxx_messageInfo_Schedule proto.InternalMessageInfo

func (m *Schedule) GetCronTabSchedule() string {
	if m != nil {
		return m.CronTabSchedule
	}
	return ""
}

func (m *Schedule) GetRepeating() bool {
	if m != nil {
		return m.Repeating
	}
	return false
}

func (m *Schedule) GetTimezone() string {
	if m != nil {
		return m.Timezone
	}
	return ""
}

func (m *Schedule) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Schedule) GetRunUntil() *timestamp.Timestamp {
	if m != nil {
		return m.RunUntil
	}
	return nil
}

type CsvImportRequest struct {
	ClassId              string       `protobuf:"bytes,1,opt,name=classId,proto3" json:"classId,omitempty"`
	Protocol             PassProtocol `protobuf:"varint,2,opt,name=protocol,proto3,enum=io.PassProtocol" json:"protocol,omitempty"`
	FileBytes            []byte       `protobuf:"bytes,3,opt,name=fileBytes,proto3" json:"fileBytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CsvImportRequest) Reset()         { *m = CsvImportRequest{} }
func (m *CsvImportRequest) String() string { return proto.CompactTextString(m) }
func (*CsvImportRequest) ProtoMessage()    {}
func (*CsvImportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c98cc3a51c7e8bfb, []int{4}
}

func (m *CsvImportRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CsvImportRequest.Unmarshal(m, b)
}
func (m *CsvImportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CsvImportRequest.Marshal(b, m, deterministic)
}
func (m *CsvImportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CsvImportRequest.Merge(m, src)
}
func (m *CsvImportRequest) XXX_Size() int {
	return xxx_messageInfo_CsvImportRequest.Size(m)
}
func (m *CsvImportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CsvImportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CsvImportRequest proto.InternalMessageInfo

func (m *CsvImportRequest) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *CsvImportRequest) GetProtocol() PassProtocol {
	if m != nil {
		return m.Protocol
	}
	return PassProtocol_RAW_PROTOCOL
}

func (m *CsvImportRequest) GetFileBytes() []byte {
	if m != nil {
		return m.FileBytes
	}
	return nil
}

func init() {
	proto.RegisterEnum("io.JobStatus", JobStatus_name, JobStatus_value)
	proto.RegisterEnum("io.JobType", JobType_name, JobType_value)
	proto.RegisterType((*Job)(nil), "io.Job")
	proto.RegisterType((*CompletedJob)(nil), "io.CompletedJob")
	proto.RegisterType((*CompletedCsvImport)(nil), "io.CompletedCsvImport")
	proto.RegisterType((*Schedule)(nil), "io.Schedule")
	proto.RegisterType((*CsvImportRequest)(nil), "io.CsvImportRequest")
}

func init() { proto.RegisterFile("io/common/job.proto", fileDescriptor_c98cc3a51c7e8bfb) }

var fileDescriptor_c98cc3a51c7e8bfb = []byte{
	// 747 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xdd, 0x6e, 0xf3, 0x34,
	0x18, 0xc7, 0xd7, 0xb4, 0xb4, 0x89, 0xdb, 0x75, 0xc1, 0x20, 0x94, 0xb7, 0x7a, 0xd1, 0x3b, 0x55,
	0x42, 0xaa, 0xa6, 0x35, 0x11, 0x03, 0x21, 0x4e, 0xe9, 0x87, 0x68, 0xbb, 0x8f, 0x56, 0x6e, 0x0b,
	0x88, 0x93, 0xca, 0x4d, 0xbc, 0xcc, 0x2c, 0x89, 0xb3, 0xd8, 0x81, 0x8d, 0x9b, 0xe1, 0x9c, 0xab,
	0xe2, 0x02, 0xb8, 0x08, 0x64, 0xe7, 0xa3, 0x1b, 0x4c, 0x64, 0x67, 0x7e, 0xfe, 0xcf, 0xef, 0xd9,
	0xec, 0xff, 0xf3, 0x4f, 0xc1, 0x27, 0x94, 0x39, 0x2e, 0x0b, 0x43, 0x16, 0x39, 0xbf, 0xb0, 0xbd,
	0x1d, 0x27, 0x4c, 0x30, 0xa8, 0x51, 0xd6, 0x7b, 0x77, 0x68, 0x28, 0xd1, 0x65, 0x01, 0xcf, 0xda,
	0xbd, 0xf3, 0x4c, 0x18, 0xfa, 0x24, 0x1a, 0xf2, 0xdf, 0xb0, 0xef, 0x93, 0xc4, 0x61, 0xb1, 0xa0,
	0x2c, 0xe2, 0x0e, 0x8e, 0x22, 0x26, 0xb0, 0x3a, 0xe7, 0xf4, 0x07, 0x9f, 0x31, 0x3f, 0x20, 0xd9,
	0x5f, 0xd9, 0xa7, 0xb7, 0x8e, 0xa0, 0x21, 0xe1, 0x02, 0x87, 0x71, 0x06, 0xf4, 0xff, 0x68, 0x80,
	0xfa, 0x82, 0xed, 0x61, 0x17, 0x68, 0xd4, 0xb3, 0x6a, 0xa7, 0xb5, 0x81, 0x81, 0x34, 0xea, 0xc1,
	0x1e, 0xd0, 0x53, 0x4e, 0x92, 0x08, 0x87, 0xc4, 0xd2, 0x94, 0x5a, 0xd6, 0xf0, 0x1c, 0xe8, 0xc5,
	0xad, 0xac, 0xfa, 0x69, 0x6d, 0xd0, 0xbd, 0x30, 0x6d, 0xca, 0xec, 0x15, 0xe6, 0x7c, 0x95, 0xeb,
	0xa8, 0x24, 0xe0, 0x17, 0xa0, 0xc9, 0x05, 0x16, 0x29, 0xb7, 0x1a, 0x8a, 0x3d, 0x96, 0xec, 0x82,
	0xed, 0xd7, 0x4a, 0x44, 0x79, 0x13, 0x7e, 0x00, 0x0d, 0xf1, 0x14, 0x13, 0xeb, 0x23, 0x05, 0xb5,
	0x73, 0x68, 0xf3, 0x14, 0x13, 0xa4, 0x1a, 0x70, 0x00, 0x74, 0xee, 0xde, 0x11, 0x2f, 0x0d, 0x88,
	0xd5, 0x3c, 0xad, 0x0d, 0xda, 0x17, 0x1d, 0x09, 0xad, 0x73, 0x0d, 0x95, 0x5d, 0xf8, 0x35, 0x68,
	0xb9, 0x09, 0xc1, 0x82, 0x78, 0x56, 0x4b, 0x81, 0x3d, 0x3b, 0xb3, 0xc1, 0x2e, 0x6c, 0xb0, 0x37,
	0x85, 0x0d, 0xa8, 0x40, 0xe5, 0x54, 0x1a, 0x7b, 0x6a, 0x4a, 0xaf, 0x9e, 0xca, 0x51, 0xf8, 0x0d,
	0xd0, 0x6f, 0x69, 0xc2, 0x05, 0x4a, 0x23, 0xcb, 0xa8, 0x1c, 0x2b, 0xd9, 0x6c, 0x2e, 0xc2, 0x81,
	0x9c, 0x03, 0x6f, 0x99, 0xcb, 0x58, 0x79, 0xcb, 0x88, 0x3c, 0xaa, 0x7f, 0xd7, 0xae, 0xbe, 0x65,
	0x8e, 0xca, 0xa9, 0x00, 0x67, 0x97, 0xec, 0x54, 0x4f, 0xe5, 0xe8, 0xa2, 0xa1, 0x1f, 0x9b, 0xdd,
	0xfe, 0xdf, 0x1a, 0xe8, 0x8c, 0x59, 0x18, 0x07, 0x44, 0x10, 0xef, 0xb5, 0xa8, 0x98, 0xa0, 0xee,
	0x52, 0x2f, 0x4f, 0x89, 0x3c, 0x4a, 0x25, 0xa5, 0x9e, 0xca, 0x86, 0x81, 0xe4, 0xf1, 0x45, 0x64,
	0x1a, 0x95, 0x91, 0xa9, 0xcc, 0xc2, 0x21, 0x53, 0xcd, 0xff, 0xcb, 0x94, 0x05, 0x5a, 0x1e, 0x11,
	0x98, 0x06, 0x5c, 0x05, 0xc1, 0x40, 0x45, 0x09, 0xbf, 0x05, 0x86, 0x5b, 0xbc, 0xe9, 0x0d, 0xeb,
	0x3e, 0xc0, 0x70, 0x06, 0x60, 0x59, 0x8c, 0xf9, 0xaf, 0xf3, 0x30, 0x66, 0x89, 0xc8, 0x57, 0xff,
	0x99, 0xbc, 0xc6, 0xf8, 0x3f, 0xdd, 0xd9, 0x11, 0x7a, 0x65, 0x66, 0xf4, 0x29, 0x80, 0xcf, 0x7d,
	0x5d, 0xa6, 0x22, 0x4e, 0x45, 0xdf, 0x7e, 0xa6, 0x96, 0xac, 0x7c, 0xc9, 0x2d, 0x0d, 0xc8, 0x36,
	0x09, 0x72, 0xe3, 0x8b, 0xb2, 0xff, 0x57, 0x0d, 0xe8, 0xc5, 0x37, 0x00, 0x07, 0xe0, 0xc4, 0x4d,
	0x58, 0xb4, 0xc1, 0xfb, 0x42, 0xca, 0xf1, 0x7f, 0xcb, 0xf0, 0x3d, 0x30, 0x12, 0x12, 0x13, 0x2c,
	0x68, 0xe4, 0xab, 0xd5, 0xe9, 0xe8, 0x20, 0xc8, 0xaf, 0x5f, 0xfe, 0x50, 0xfc, 0xce, 0x22, 0x92,
	0x6f, 0xb1, 0xac, 0xa5, 0x75, 0x5c, 0xe0, 0x44, 0x48, 0x77, 0xd4, 0x2e, 0x2b, 0xac, 0x2b, 0x61,
	0x99, 0xf9, 0x24, 0x8d, 0xb6, 0x91, 0xa0, 0x81, 0x5a, 0x6d, 0x45, 0xe6, 0x0b, 0xb6, 0xff, 0x08,
	0xcc, 0xd2, 0x09, 0x44, 0x1e, 0x52, 0xc2, 0x95, 0x21, 0x6e, 0x80, 0x39, 0x9f, 0x17, 0x49, 0x2c,
	0xca, 0x17, 0x51, 0xd3, 0x2a, 0xa3, 0xf6, 0x1e, 0x18, 0xd2, 0xc9, 0xd1, 0x93, 0x20, 0x5c, 0x3d,
	0xb5, 0x83, 0x0e, 0xc2, 0xd9, 0x03, 0x30, 0xca, 0x54, 0xc1, 0x8f, 0xc1, 0xf1, 0x62, 0x39, 0xda,
	0xad, 0xc7, 0xb3, 0xe9, 0x64, 0x7b, 0x35, 0x9d, 0x98, 0x47, 0xf0, 0x04, 0xb4, 0xa5, 0x84, 0xb6,
	0x37, 0x37, 0xf3, 0x9b, 0xef, 0xcd, 0x1a, 0xec, 0x02, 0x20, 0x85, 0xd5, 0x77, 0xdb, 0xf5, 0x74,
	0x62, 0x6a, 0xc5, 0xcc, 0x78, 0x79, 0xbd, 0xba, 0x9a, 0x6e, 0xa6, 0x13, 0xb3, 0x0e, 0x3f, 0x07,
	0xef, 0x5e, 0x48, 0xbb, 0x1f, 0xe7, 0x9b, 0xd9, 0x6e, 0x8a, 0xd0, 0x12, 0xad, 0xcd, 0xc6, 0xd9,
	0x97, 0xa0, 0x95, 0x67, 0x1d, 0x42, 0xd0, 0x55, 0xe4, 0xfa, 0x87, 0xdd, 0xfc, 0x7a, 0xb5, 0x44,
	0x1b, 0xf3, 0xe8, 0xb9, 0x36, 0xfd, 0x49, 0x69, 0xb5, 0xd1, 0x08, 0x9c, 0x50, 0x66, 0xc7, 0x98,
	0xf3, 0x7b, 0x2a, 0xec, 0xd5, 0x25, 0x65, 0x3f, 0x0f, 0x7c, 0x2a, 0xee, 0xd2, 0xbd, 0xed, 0xb2,
	0xd0, 0x91, 0x2f, 0xbf, 0xa4, 0xc2, 0xc9, 0x81, 0xa1, 0xcf, 0x02, 0x1c, 0xf9, 0x43, 0xee, 0xdd,
	0x3b, 0x94, 0xfd, 0xa9, 0x35, 0x56, 0x97, 0x73, 0xb6, 0x6f, 0x2a, 0x47, 0xbe, 0xfa, 0x27, 0x00,
	0x00, 0xff, 0xff, 0x49, 0x55, 0x16, 0xd0, 0x93, 0x06, 0x00, 0x00,
}
