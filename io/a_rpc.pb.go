// Code generated by protoc-gen-go. DO NOT EDIT.
// source: io/core/a_rpc.proto

package io

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("io/core/a_rpc.proto", fileDescriptor_97cd888ecc02e359) }

var fileDescriptor_97cd888ecc02e359 = []byte{
	// 2817 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0x5d, 0x6c, 0x5c, 0xc5,
	0xf5, 0xd7, 0x6c, 0x88, 0x4d, 0xc6, 0xeb, 0x8f, 0x8c, 0x3f, 0x73, 0x63, 0x92, 0xc9, 0xe5, 0x23,
	0x60, 0xfe, 0xec, 0x2e, 0x4e, 0xc2, 0x03, 0xff, 0xb6, 0xe2, 0xda, 0x21, 0xc8, 0x26, 0x50, 0xd7,
	0x1f, 0x44, 0xa2, 0x2a, 0xd6, 0xec, 0xbd, 0xe3, 0xf5, 0xc4, 0x77, 0xef, 0x6c, 0xef, 0xcc, 0xae,
	0x31, 0x51, 0x5a, 0x88, 0x5a, 0x51, 0x09, 0x54, 0xa4, 0x2d, 0xea, 0x63, 0xa1, 0xa5, 0x52, 0xa5,
	0xbc, 0xb4, 0x45, 0x6a, 0x2b, 0x35, 0xe2, 0x89, 0x4a, 0x7d, 0xad, 0x40, 0x42, 0xaa, 0x2a, 0x95,
	0x4a, 0x45, 0x3c, 0xb6, 0x2f, 0x95, 0xfa, 0x5a, 0xcd, 0xcc, 0xfd, 0xdc, 0xf5, 0x3a, 0x86, 0x2c,
	0xa5, 0x2f, 0xb6, 0xef, 0x99, 0x99, 0xdf, 0x99, 0xdf, 0x39, 0x67, 0xce, 0x39, 0x73, 0xaf, 0xe1,
	0x38, 0xe3, 0x65, 0x97, 0x87, 0xb4, 0x4c, 0x36, 0xc3, 0x86, 0x5b, 0x6a, 0x84, 0x5c, 0x72, 0x54,
	0x60, 0xdc, 0x9a, 0xad, 0x71, 0x5e, 0xf3, 0x69, 0x99, 0x34, 0x58, 0x99, 0x04, 0x01, 0x97, 0x44,
	0x32, 0x1e, 0x08, 0x33, 0xc3, 0x3a, 0x19, 0x8d, 0xea, 0xa7, 0x6a, 0x73, 0xab, 0x4c, 0xeb, 0x0d,
	0xb9, 0x17, 0x0d, 0xfe, 0x9f, 0xfe, 0xe5, 0x3e, 0x52, 0xa3, 0xc1, 0x23, 0x62, 0x97, 0xd4, 0x6a,
	0x34, 0x2c, 0xf3, 0x86, 0x5e, 0xbe, 0x1f, 0x14, 0xe3, 0x5a, 0x89, 0xcb, 0xeb, 0x75, 0x1e, 0x6c,
	0xf2, 0xea, 0x55, 0xea, 0xca, 0x78, 0x10, 0xab, 0xed, 0xd1, 0x50, 0xb2, 0x2d, 0xe6, 0x12, 0x49,
	0xb3, 0x7f, 0x47, 0x33, 0x66, 0x35, 0x01, 0xb5, 0xb4, 0xec, 0x31, 0x21, 0x43, 0x56, 0x6d, 0x2a,
	0xf4, 0x68, 0x74, 0x3a, 0x1d, 0x6d, 0x84, 0x5c, 0x21, 0x47, 0x03, 0x33, 0xe9, 0x80, 0xa4, 0xf5,
	0x86, 0x9f, 0x02, 0x66, 0x96, 0xd4, 0xa9, 0x10, 0xa4, 0x16, 0x0f, 0x8c, 0xa7, 0x03, 0x57, 0x79,
	0x35, 0x12, 0x5a, 0x19, 0x05, 0xa4, 0xc6, 0x02, 0x92, 0x51, 0x3e, 0xc1, 0x78, 0x99, 0xd5, 0x49,
	0x8d, 0x9a, 0x9f, 0x91, 0x14, 0x31, 0x5e, 0x6e, 0x0a, 0x1a, 0xea, 0x1f, 0x46, 0x36, 0xff, 0x29,
	0x84, 0xc5, 0xc5, 0x94, 0x9a, 0x40, 0xaf, 0x02, 0x38, 0x5b, 0xa3, 0x32, 0x23, 0x5b, 0x63, 0xb5,
	0x80, 0x05, 0xb5, 0x55, 0xfa, 0xed, 0x26, 0x15, 0x12, 0x4d, 0x95, 0x8c, 0x07, 0x4a, 0xb1, 0x07,
	0x4a, 0x4f, 0x2a, 0x0f, 0x58, 0xf7, 0x94, 0x18, 0x2f, 0xf5, 0x5c, 0x66, 0x57, 0x6e, 0x7c, 0xf8,
	0xc9, 0x8f, 0x0a, 0x73, 0xe8, 0xc1, 0x5e, 0x56, 0xdd, 0x14, 0x66, 0xc1, 0x66, 0x18, 0x29, 0xf2,
	0xe0, 0x38, 0xf1, 0x3c, 0xa7, 0xd1, 0xf0, 0x69, 0x06, 0x16, 0x0d, 0x2b, 0x3d, 0x97, 0x98, 0x4f,
	0x17, 0xf6, 0x24, 0x15, 0xd6, 0x78, 0x87, 0xda, 0x8b, 0x44, 0x12, 0xfb, 0x21, 0xad, 0xec, 0x5e,
	0xfb, 0x54, 0x4e, 0x19, 0x51, 0x50, 0x9b, 0x19, 0xc9, 0xe3, 0x60, 0x0e, 0xd5, 0xe0, 0x54, 0xb3,
	0xe1, 0x11, 0x49, 0xef, 0x44, 0x91, 0x75, 0x08, 0x45, 0x0c, 0x4e, 0xd7, 0xa8, 0xec, 0xd4, 0xa2,
	0x50, 0xd0, 0x94, 0x82, 0x5e, 0x21, 0x42, 0xac, 0xef, 0x35, 0xe8, 0x92, 0x47, 0x03, 0x35, 0x4a,
	0xc3, 0xfd, 0x55, 0x9e, 0xd1, 0x2a, 0x4f, 0xa2, 0x13, 0x39, 0x95, 0xd7, 0x1a, 0xc9, 0xf2, 0xeb,
	0x68, 0x03, 0x4e, 0xfa, 0x4c, 0x74, 0xe9, 0x12, 0x68, 0xc4, 0x28, 0x8a, 0xa3, 0x65, 0x7f, 0x05,
	0x93, 0x5a, 0xc1, 0x28, 0x1a, 0xce, 0x2a, 0x10, 0x15, 0x80, 0x56, 0xe0, 0x94, 0xcb, 0x9b, 0xc1,
	0x21, 0x70, 0x8f, 0x69, 0x5c, 0x35, 0xd7, 0x3e, 0xa9, 0xd1, 0x26, 0xd1, 0x78, 0x0e, 0xad, 0xac,
	0x81, 0xd0, 0x1a, 0x1c, 0x26, 0x9e, 0xb7, 0x12, 0xb2, 0x16, 0x91, 0xf4, 0x69, 0xba, 0x87, 0x26,
	0x35, 0x50, 0xf2, 0x1c, 0x05, 0x8f, 0x35, 0xa0, 0xc4, 0x4b, 0x9e, 0x7d, 0xaf, 0x06, 0xbb, 0xc7,
	0x9e, 0xc9, 0x71, 0x6f, 0x98, 0xf9, 0x9b, 0x3b, 0x74, 0x4f, 0x19, 0xfa, 0x0a, 0x1c, 0xf3, 0xa8,
	0x4f, 0x25, 0xcd, 0xe0, 0x46, 0x00, 0x56, 0x8f, 0xe0, 0x8d, 0x81, 0xe7, 0x0e, 0x04, 0x7e, 0x1e,
	0x8e, 0x2a, 0xb3, 0xa6, 0xb0, 0xdd, 0xc4, 0x51, 0x7e, 0xff, 0x07, 0x38, 0x2c, 0x83, 0xad, 0x6c,
	0xfb, 0x1c, 0x1c, 0xd3, 0x26, 0x39, 0x08, 0x3c, 0x63, 0xd5, 0xb3, 0x1a, 0xf3, 0x0c, 0x3a, 0xdd,
	0x13, 0x33, 0xb2, 0xf0, 0x26, 0x3c, 0x4e, 0x3c, 0x6f, 0xfd, 0xf2, 0x5a, 0x36, 0xb2, 0x4f, 0x28,
	0xa0, 0xbc, 0xac, 0xd3, 0xd2, 0x91, 0x02, 0x7b, 0x36, 0xa7, 0x40, 0xfa, 0xa2, 0x33, 0xac, 0x37,
	0xe1, 0x84, 0xb1, 0x76, 0x87, 0x8e, 0xdb, 0x59, 0x3c, 0x52, 0x30, 0x77, 0x5b, 0x05, 0x14, 0x8e,
	0x2b, 0xab, 0xe7, 0xe1, 0xbb, 0x8d, 0x33, 0xd5, 0xcd, 0x49, 0x5b, 0xff, 0x3e, 0xad, 0xe7, 0x14,
	0x3a, 0x50, 0x4f, 0x05, 0xa0, 0x17, 0xe0, 0x84, 0xb6, 0xd8, 0xed, 0xf4, 0x64, 0x9c, 0xf0, 0xb0,
	0x86, 0xbe, 0x1f, 0xdd, 0x7b, 0x10, 0x74, 0xe4, 0x88, 0xf9, 0xbf, 0x8c, 0xc3, 0x63, 0xeb, 0x51,
	0xbe, 0x17, 0xe8, 0x13, 0x00, 0x47, 0xdc, 0x90, 0x12, 0x49, 0x63, 0x19, 0x1a, 0x4b, 0x92, 0x40,
	0x24, 0x49, 0x7c, 0xf1, 0x3b, 0xd0, 0x76, 0xde, 0x02, 0x68, 0x62, 0x51, 0x2f, 0xc0, 0x6a, 0x0e,
	0x4e, 0x26, 0x9d, 0x36, 0x52, 0x81, 0x09, 0x56, 0x29, 0x00, 0xc7, 0x35, 0x05, 0x87, 0xd4, 0xe5,
	0xa1, 0x57, 0x5a, 0xae, 0xc0, 0x23, 0xe7, 0x2b, 0x15, 0xf4, 0x10, 0x3c, 0xbb, 0xbe, 0x4d, 0x43,
	0x8a, 0x99, 0x9e, 0x1a, 0xf2, 0xaa, 0x4f, 0xeb, 0x78, 0x97, 0xc9, 0x6d, 0x2c, 0xb7, 0x29, 0x66,
	0x41, 0xa3, 0x29, 0xb1, 0x47, 0x24, 0x29, 0x2d, 0x9f, 0x57, 0x2b, 0xce, 0xa1, 0x47, 0xe0, 0xc3,
	0xab, 0x54, 0x36, 0xc3, 0x80, 0x7a, 0x78, 0x77, 0x9b, 0x06, 0x7a, 0x9e, 0x2a, 0x1d, 0xd8, 0x27,
	0xee, 0x8e, 0xc0, 0xa4, 0x29, 0xb7, 0x79, 0xc8, 0x5e, 0x32, 0x85, 0x47, 0xdb, 0x62, 0xc4, 0x3e,
	0x96, 0x14, 0x35, 0xe5, 0xbb, 0x8f, 0x0a, 0x70, 0xc4, 0x64, 0xd7, 0x03, 0x68, 0x76, 0x49, 0xec,
	0xb7, 0x0a, 0x6d, 0xe7, 0xd5, 0x02, 0x9a, 0xd8, 0xd0, 0x4b, 0x3b, 0x08, 0x63, 0x23, 0x15, 0x98,
	0x04, 0x7d, 0x63, 0x6c, 0x1b, 0xc6, 0x27, 0xe1, 0x89, 0x8d, 0x5e, 0xfc, 0x96, 0x4f, 0xa9, 0x39,
	0xe7, 0xd1, 0x34, 0x9c, 0x5c, 0xd5, 0x7a, 0xf0, 0x2e, 0x11, 0x38, 0xe0, 0x12, 0x6f, 0xf1, 0x66,
	0xe0, 0x95, 0x96, 0xaf, 0xc0, 0x23, 0x17, 0x2a, 0xe7, 0xd0, 0x0a, 0x7c, 0x76, 0x8d, 0x86, 0x2d,
	0x1a, 0x2a, 0xb5, 0xcd, 0x80, 0xb4, 0x08, 0xf3, 0x49, 0xd5, 0xa7, 0x25, 0xbc, 0x40, 0xdc, 0x1d,
	0xcc, 0xb7, 0xb6, 0xf0, 0x16, 0x0f, 0xf1, 0xfc, 0x85, 0x4a, 0x5d, 0x51, 0xf0, 0x70, 0x48, 0x1b,
	0x94, 0x48, 0x1c, 0x55, 0x3d, 0xdc, 0x0c, 0x24, 0xf3, 0xb1, 0x68, 0xba, 0x2e, 0x15, 0x62, 0xab,
	0xe9, 0x47, 0x86, 0xb5, 0xf2, 0x86, 0xfd, 0x00, 0xc0, 0xa1, 0x1a, 0x95, 0x89, 0x55, 0xe3, 0xd3,
	0x36, 0xd3, 0x69, 0xcb, 0x55, 0x2a, 0x1a, 0x3c, 0x10, 0xd4, 0x7e, 0x1b, 0xb4, 0x9d, 0x57, 0x00,
	0x9a, 0x79, 0x8a, 0xca, 0xbc, 0x41, 0xb1, 0xa1, 0x63, 0x9d, 0x59, 0xa5, 0x32, 0x64, 0xb4, 0x75,
	0x40, 0x28, 0xf5, 0xc1, 0x4c, 0x49, 0x35, 0x88, 0xc1, 0xcb, 0xca, 0x03, 0xe5, 0x6b, 0xcc, 0xbb,
	0x8e, 0x5e, 0x2e, 0x40, 0x54, 0xa3, 0xf2, 0x22, 0xdd, 0x22, 0x4d, 0x3f, 0xe5, 0x66, 0x29, 0x4e,
	0x1d, 0xc2, 0x38, 0x5d, 0x75, 0xc7, 0xce, 0x2d, 0xd0, 0x76, 0x5e, 0x03, 0xc8, 0x56, 0x3c, 0x1d,
	0x1c, 0x2d, 0xfb, 0xd2, 0x19, 0x3f, 0x80, 0xee, 0xeb, 0x64, 0x6c, 0x5a, 0x55, 0xee, 0x5f, 0x2f,
	0x5f, 0x0b, 0x69, 0x8b, 0x09, 0xc6, 0x83, 0xeb, 0xe8, 0x6f, 0x00, 0x16, 0x5d, 0xde, 0xd8, 0x4b,
	0xc8, 0x4f, 0x9a, 0x74, 0x93, 0x4a, 0x96, 0x54, 0xd8, 0x26, 0xa9, 0xe1, 0x57, 0xa0, 0xed, 0xfc,
	0x18, 0xa0, 0x93, 0x6a, 0x06, 0x26, 0xfb, 0xd3, 0x3c, 0xb7, 0xc8, 0x1b, 0xac, 0x27, 0xc7, 0x28,
	0x06, 0xd5, 0x39, 0x57, 0x53, 0x02, 0xba, 0x8b, 0x59, 0x1f, 0x89, 0x8f, 0xd9, 0x23, 0x29, 0x71,
	0xc5, 0x0c, 0xfd, 0x11, 0xc0, 0x91, 0xa8, 0x62, 0x74, 0x46, 0x6f, 0xaf, 0x5a, 0xf1, 0x26, 0x68,
	0x3b, 0xd7, 0xd0, 0xc4, 0x45, 0xbd, 0xaa, 0x33, 0xff, 0x19, 0x69, 0xcf, 0x74, 0xd0, 0x3f, 0x26,
	0x73, 0x19, 0x26, 0x3a, 0x5e, 0x6f, 0x14, 0xe0, 0x84, 0x2e, 0x4d, 0x71, 0x5a, 0xbf, 0xc4, 0x43,
	0xa5, 0xa3, 0xab, 0x66, 0xf4, 0x3e, 0x95, 0xef, 0x81, 0xb6, 0xf3, 0x33, 0x80, 0x4e, 0xeb, 0x68,
	0xf5, 0xfd, 0x3c, 0x37, 0x81, 0x2f, 0xf1, 0x10, 0x2b, 0x44, 0xeb, 0xff, 0x33, 0xa1, 0xea, 0xfb,
	0x79, 0xa2, 0x02, 0x0b, 0xc9, 0x43, 0xea, 0xe1, 0x66, 0xe0, 0xd1, 0x30, 0xcd, 0xd2, 0xc4, 0xd5,
	0x95, 0xa7, 0x7f, 0xbe, 0x3c, 0x8e, 0x46, 0x13, 0x0b, 0x08, 0x7d, 0x89, 0xa8, 0x00, 0xf4, 0x2f,
	0x00, 0x87, 0x73, 0x46, 0xf8, 0x0c, 0xec, 0x7f, 0x0b, 0xda, 0xce, 0xdb, 0xf1, 0x59, 0xdd, 0x9f,
	0xfd, 0x22, 0xaf, 0x37, 0x48, 0xb0, 0x67, 0x3d, 0xf6, 0xd9, 0x0c, 0xe0, 0x9a, 0x65, 0xfd, 0xe3,
	0x5e, 0x44, 0x30, 0xe5, 0x5e, 0x01, 0xe8, 0x7b, 0x05, 0x38, 0x62, 0xfa, 0x85, 0x9e, 0xbc, 0x33,
	0x9d, 0xc2, 0x47, 0xa0, 0xed, 0xfc, 0x1e, 0x20, 0xf3, 0xb4, 0x1f, 0x55, 0x27, 0x2e, 0x13, 0x58,
	0x72, 0xbc, 0xbe, 0x4d, 0x8d, 0xd7, 0x2f, 0x66, 0x13, 0x94, 0xd6, 0x86, 0xf9, 0xd6, 0xa1, 0x9c,
	0x7f, 0x56, 0xf4, 0xdf, 0x04, 0x08, 0x8d, 0x65, 0xdc, 0x6f, 0xda, 0xcb, 0xef, 0x17, 0xe0, 0x64,
	0xde, 0x0c, 0xbd, 0xce, 0x40, 0xc6, 0x1a, 0x7f, 0x02, 0x6d, 0xe7, 0x97, 0x00, 0xcd, 0xf5, 0xb4,
	0xc6, 0xd7, 0x77, 0x55, 0xcf, 0x51, 0xdd, 0x4b, 0x2d, 0xf1, 0xd5, 0xcf, 0x1e, 0xff, 0x67, 0x45,
	0xff, 0x4f, 0xc0, 0x34, 0x9a, 0xec, 0x38, 0x01, 0x51, 0x77, 0xf7, 0xc1, 0x14, 0x1c, 0x58, 0x52,
	0x57, 0x6d, 0x81, 0xbe, 0x09, 0x47, 0x05, 0x95, 0x2b, 0x21, 0xdf, 0x62, 0x3e, 0xd5, 0xb2, 0xf8,
	0x56, 0x93, 0x4a, 0x4c, 0x12, 0xef, 0x95, 0xee, 0x4e, 0x68, 0x5d, 0xe3, 0xf6, 0x48, 0x74, 0x87,
	0x6f, 0x98, 0x95, 0xaa, 0xee, 0x2f, 0xc3, 0xd1, 0x5a, 0x07, 0x78, 0xaf, 0xfb, 0xf8, 0xa0, 0x52,
	0xba, 0x11, 0xfa, 0xf6, 0x94, 0x49, 0x5f, 0xa8, 0x03, 0x0e, 0x2d, 0xc2, 0xf1, 0x0e, 0xac, 0x85,
	0xbd, 0x25, 0x2f, 0x49, 0xc6, 0xc9, 0xfa, 0xf4, 0x06, 0x97, 0x5b, 0x6f, 0x72, 0xe0, 0x9f, 0x55,
	0xc1, 0xd2, 0x1d, 0x68, 0x44, 0x7f, 0x42, 0xfb, 0x39, 0x95, 0x18, 0xaa, 0x45, 0x0d, 0xaa, 0x9f,
	0x3d, 0x61, 0xff, 0x1c, 0xb4, 0x9d, 0x1f, 0x02, 0x34, 0x1c, 0x35, 0xb4, 0x66, 0xa5, 0x35, 0x19,
	0x77, 0xb2, 0x5a, 0xcd, 0x97, 0xd2, 0xbf, 0x16, 0xed, 0x41, 0x43, 0x52, 0x28, 0x63, 0xbf, 0x5f,
	0x80, 0x43, 0xa6, 0x7b, 0x35, 0x96, 0xd6, 0xd4, 0x36, 0x52, 0x81, 0xa1, 0x36, 0x9a, 0x50, 0x33,
	0x71, 0x63, 0xbf, 0x5e, 0x68, 0x3b, 0xff, 0x06, 0xa8, 0x18, 0x75, 0xaf, 0x7a, 0xc8, 0x9a, 0xc9,
	0x74, 0xad, 0x77, 0xca, 0xef, 0x7f, 0xbe, 0x5b, 0x1d, 0xb2, 0x06, 0x8c, 0x19, 0x95, 0x15, 0xdf,
	0x31, 0xad, 0xaa, 0x36, 0xc3, 0xc6, 0xea, 0xe5, 0xee, 0xf8, 0xba, 0x01, 0xda, 0x8e, 0x8f, 0x86,
	0x55, 0x11, 0xd0, 0x93, 0xf0, 0xc6, 0xea, 0x65, 0x6b, 0x3a, 0x73, 0xe0, 0x63, 0x8b, 0x35, 0x43,
	0xbf, 0x7f, 0x47, 0x79, 0x18, 0x0d, 0x45, 0xf1, 0xac, 0xe3, 0xf8, 0x16, 0x80, 0x23, 0xf1, 0x2e,
	0x17, 0x9a, 0x81, 0xe7, 0xa7, 0x5d, 0x49, 0xea, 0x60, 0x33, 0x60, 0xbf, 0x01, 0xda, 0x4e, 0x88,
	0xc6, 0xd2, 0x0d, 0x1b, 0xb9, 0x65, 0xed, 0xb3, 0xe7, 0xaa, 0x1e, 0xea, 0xdf, 0xb6, 0x27, 0x10,
	0x8a, 0xb6, 0x6d, 0x90, 0xcd, 0xee, 0x7f, 0x03, 0x60, 0x31, 0xde, 0xbd, 0x7e, 0xa3, 0xd4, 0xbd,
	0xf7, 0x28, 0x38, 0x5f, 0x03, 0x6d, 0xa7, 0x81, 0x46, 0xd2, 0xbd, 0xab, 0xe9, 0xfb, 0xee, 0xbc,
	0xdf, 0x2d, 0xb0, 0x2a, 0x1f, 0x66, 0xe7, 0x69, 0xc7, 0xff, 0x31, 0x80, 0x13, 0x35, 0x2a, 0x2f,
	0x73, 0x97, 0xf8, 0xec, 0x25, 0xea, 0x25, 0x41, 0x32, 0xad, 0xf6, 0x9d, 0x17, 0x9b, 0xd3, 0x96,
	0x44, 0x8d, 0xca, 0x21, 0xdf, 0x45, 0xd3, 0x8a, 0x48, 0x32, 0x2f, 0x13, 0x3f, 0x38, 0x5b, 0x3a,
	0xfd, 0x64, 0x02, 0x8b, 0x27, 0xf4, 0x8f, 0xd7, 0x2c, 0xb2, 0x32, 0x81, 0x54, 0xbe, 0xe6, 0x93,
	0xa0, 0xd6, 0x24, 0x35, 0xba, 0xc8, 0x3d, 0x7a, 0x1d, 0xfd, 0x1a, 0xc0, 0x21, 0xd3, 0xed, 0x9a,
	0x1c, 0x72, 0xbb, 0x56, 0xf7, 0x15, 0xd0, 0x76, 0x76, 0x50, 0x31, 0x6a, 0x75, 0x4d, 0xee, 0x98,
	0xce, 0xb4, 0xb8, 0x59, 0xdf, 0xf4, 0xef, 0x2c, 0xcc, 0xe5, 0xce, 0xc2, 0xa7, 0x20, 0x7e, 0xa7,
	0x93, 0xf7, 0x40, 0x6f, 0xaf, 0x74, 0x85, 0xd9, 0x3b, 0xa0, 0xed, 0x7c, 0x07, 0x4d, 0x45, 0x34,
	0x3a, 0x1c, 0x64, 0xe1, 0x84, 0x50, 0x97, 0x6b, 0xfa, 0xcc, 0x6c, 0x76, 0xee, 0x20, 0xe7, 0xfc,
	0x1d, 0xc0, 0xe3, 0xaa, 0x77, 0x35, 0x05, 0xa8, 0x57, 0xe7, 0xd2, 0x45, 0xee, 0x26, 0x68, 0x3b,
	0x6d, 0x60, 0x62, 0x4f, 0x75, 0x2f, 0x66, 0x79, 0xda, 0xac, 0x9f, 0xcb, 0x37, 0x2b, 0xa6, 0xa0,
	0xfc, 0xb7, 0x9a, 0xf4, 0x11, 0x54, 0x8c, 0x4a, 0x58, 0xdc, 0xa1, 0x7f, 0x08, 0x20, 0x4c, 0x59,
	0xde, 0x9e, 0xde, 0x4f, 0x4d, 0x75, 0x9e, 0x89, 0xe9, 0xa5, 0xbd, 0x69, 0x54, 0xa8, 0x4b, 0x87,
	0xe3, 0xd7, 0xf7, 0x06, 0xf4, 0x18, 0x8a, 0xab, 0x73, 0x05, 0xa0, 0x7f, 0x00, 0x38, 0xa4, 0x4d,
	0xd7, 0x83, 0x56, 0xa6, 0xdf, 0x7c, 0x1f, 0xb4, 0x9d, 0x9b, 0x00, 0x3d, 0x90, 0xf6, 0x9b, 0x91,
	0xc7, 0xf6, 0xef, 0xba, 0xbf, 0xb2, 0x6f, 0xd7, 0x7d, 0x90, 0x17, 0xbf, 0x88, 0x6e, 0x7b, 0x14,
	0x0d, 0xc7, 0x7e, 0x34, 0xad, 0xf6, 0x3f, 0x01, 0x44, 0x19, 0xc2, 0x87, 0xe8, 0xb3, 0xdf, 0x33,
	0xef, 0x0d, 0xed, 0x2e, 0xde, 0xdd, 0xfd, 0xf5, 0x85, 0xc3, 0x87, 0xec, 0x17, 0xd1, 0x57, 0x27,
	0x55, 0x2d, 0xd7, 0x54, 0xbf, 0x3e, 0x08, 0x8f, 0x2a, 0x5c, 0x81, 0x9e, 0x80, 0x23, 0x4a, 0x1e,
	0x90, 0x3a, 0x7d, 0xf2, 0x45, 0x26, 0xa4, 0x48, 0xf2, 0xe8, 0x90, 0xfa, 0xbd, 0xc0, 0xb9, 0x4f,
	0x49, 0x10, 0x37, 0xce, 0xe8, 0xb8, 0x41, 0xa1, 0x7a, 0xaa, 0xc9, 0x69, 0x4f, 0x40, 0x68, 0xda,
	0x54, 0x6d, 0x34, 0xbd, 0xea, 0x59, 0xba, 0xab, 0xb9, 0x8f, 0x67, 0x1e, 0x92, 0xab, 0xe9, 0x98,
	0x86, 0x82, 0xf6, 0x51, 0x0d, 0xa5, 0xfa, 0x98, 0x0b, 0x70, 0x30, 0x30, 0x93, 0xf2, 0xcb, 0x75,
	0x45, 0x5a, 0xbe, 0xb2, 0x6e, 0x4f, 0x24, 0xaf, 0x40, 0xb5, 0xf6, 0x80, 0xee, 0xaa, 0x65, 0x8f,
	0xc1, 0x81, 0x16, 0x0d, 0xd9, 0xd6, 0xde, 0xfe, 0x5b, 0x9e, 0x36, 0x37, 0x6b, 0xab, 0x68, 0x16,
	0x99, 0xa9, 0x6a, 0xdd, 0x0b, 0x70, 0x3a, 0xa4, 0x82, 0x06, 0xde, 0x73, 0x4a, 0xc4, 0x5c, 0x6d,
	0xcd, 0x27, 0xeb, 0x84, 0xf9, 0x3d, 0x3b, 0xfe, 0x1c, 0xf0, 0x29, 0x0d, 0x3c, 0x63, 0x8f, 0x67,
	0x81, 0xcb, 0x06, 0x52, 0xe1, 0x3f, 0x03, 0x07, 0x6b, 0x54, 0x6a, 0x3a, 0xbd, 0xf0, 0xb4, 0x61,
	0x9e, 0x32, 0x93, 0x12, 0xc3, 0xa4, 0x5f, 0x87, 0x34, 0x6e, 0x7c, 0x99, 0x38, 0x0f, 0x8f, 0xfa,
	0xbc, 0xc6, 0x02, 0x34, 0x1a, 0xf5, 0xff, 0xfa, 0x2b, 0x16, 0xf1, 0x45, 0x6a, 0x9f, 0xe3, 0xa6,
	0x37, 0xb4, 0x07, 0xca, 0x7a, 0xa6, 0xda, 0xc4, 0x0a, 0x1c, 0x56, 0x3b, 0x92, 0xea, 0xfe, 0xb7,
	0xcb, 0x43, 0xaf, 0x7b, 0x75, 0xaf, 0x3a, 0x19, 0x5d, 0x6a, 0xac, 0x21, 0xb3, 0x0d, 0x8d, 0xa2,
	0x10, 0xbf, 0xa5, 0x5f, 0x21, 0xae, 0x98, 0x2f, 0xae, 0xc9, 0x21, 0x99, 0x8e, 0x2e, 0x60, 0x4a,
	0xb8, 0x26, 0x89, 0x6c, 0x8a, 0x4b, 0xcc, 0x97, 0x34, 0x34, 0x26, 0x8b, 0x06, 0xec, 0xd3, 0x1a,
	0xf3, 0x04, 0x9a, 0x8e, 0xbf, 0xd8, 0x46, 0xd1, 0x78, 0x4d, 0xe8, 0x25, 0xd7, 0x2b, 0x00, 0x7d,
	0x43, 0xf7, 0xb2, 0x31, 0xfc, 0x21, 0x71, 0xad, 0x24, 0xc6, 0x13, 0xdc, 0x0c, 0xe4, 0x02, 0x1c,
	0x4b, 0x21, 0x17, 0xf6, 0x36, 0x9a, 0xcc, 0xcb, 0x87, 0x4a, 0x0c, 0x93, 0x46, 0x77, 0x02, 0xc3,
	0x3c, 0x13, 0xdd, 0x2e, 0xc4, 0x29, 0x86, 0x13, 0x78, 0xf1, 0x55, 0x7a, 0x61, 0x6f, 0x6d, 0x9b,
	0x87, 0x52, 0x55, 0xbb, 0x04, 0x73, 0x36, 0x83, 0x99, 0x19, 0x5f, 0xa5, 0xa2, 0xe9, 0xef, 0xab,
	0x44, 0xb8, 0x5a, 0xc9, 0xfc, 0x1b, 0x47, 0xe0, 0xdd, 0xcf, 0x98, 0xef, 0xd2, 0x02, 0xfd, 0x01,
	0xc0, 0x21, 0x15, 0x4a, 0x91, 0xc0, 0x1c, 0x89, 0xe8, 0x21, 0x79, 0x3b, 0xf9, 0x16, 0x68, 0x3b,
	0x3f, 0x00, 0xa8, 0xb8, 0x46, 0x03, 0x0f, 0xc7, 0x83, 0x97, 0xd2, 0x0f, 0x16, 0x01, 0xdd, 0xc5,
	0xd1, 0x97, 0x6e, 0xcc, 0xcc, 0xfd, 0x4c, 0xf5, 0x86, 0x55, 0x22, 0xa8, 0xbe, 0x6c, 0x34, 0xe3,
	0x3b, 0x93, 0xef, 0xe3, 0x90, 0xfa, 0xb4, 0x45, 0x02, 0xa9, 0xef, 0xfe, 0x54, 0x7c, 0x8e, 0x7b,
	0x93, 0x69, 0x75, 0xec, 0xbb, 0xe3, 0x8f, 0xeb, 0x2a, 0x5c, 0x6e, 0x99, 0xcb, 0x49, 0x42, 0xab,
	0x33, 0x9b, 0x66, 0x69, 0xd9, 0xaf, 0x83, 0xb6, 0xf3, 0x22, 0x2a, 0xaa, 0xba, 0x18, 0x2f, 0xe8,
	0x7c, 0x2f, 0x15, 0x41, 0x0b, 0x5c, 0x27, 0xd2, 0xdd, 0x66, 0x41, 0xcd, 0x54, 0xc2, 0x90, 0x49,
	0x1a, 0x32, 0xbd, 0xbd, 0x16, 0xf3, 0xa8, 0xf7, 0x79, 0x77, 0x3f, 0x84, 0x8e, 0xc5, 0xbb, 0x17,
	0x15, 0x30, 0x7f, 0xab, 0x00, 0x8b, 0x17, 0x33, 0xff, 0x7a, 0x80, 0x6e, 0x16, 0xe0, 0x98, 0xf2,
	0xca, 0x15, 0xea, 0xbb, 0xbc, 0x4e, 0x4d, 0xba, 0xd0, 0x0e, 0xd7, 0x7f, 0x66, 0xe7, 0xc6, 0x6f,
	0xd0, 0x7b, 0x1d, 0xb0, 0x8f, 0x41, 0xdb, 0x79, 0x0f, 0x20, 0xa4, 0x7d, 0x17, 0xe1, 0x61, 0x8d,
	0x62, 0x95, 0x94, 0x4c, 0xed, 0x77, 0x37, 0x12, 0x53, 0x25, 0x56, 0x35, 0x54, 0x35, 0xa8, 0x81,
	0xc7, 0x5a, 0xcc, 0x6b, 0x12, 0xff, 0x0e, 0x6e, 0xb8, 0xb7, 0xbb, 0xbd, 0xde, 0xaf, 0x6e, 0xaf,
	0x15, 0x74, 0x0a, 0xce, 0x1a, 0x44, 0x35, 0xac, 0x75, 0x4b, 0x55, 0x24, 0x7c, 0x4c, 0xc3, 0x90,
	0x87, 0xa5, 0x24, 0x03, 0x66, 0xff, 0x3d, 0xa3, 0xac, 0x37, 0xfb, 0x38, 0x98, 0x9b, 0x7f, 0xf7,
	0x2e, 0x78, 0xd7, 0x32, 0xaf, 0x0a, 0xf4, 0x57, 0x00, 0x8f, 0xb1, 0x7a, 0x43, 0x1d, 0x04, 0xd1,
	0x8a, 0x5e, 0x60, 0x88, 0xd6, 0x92, 0x96, 0x74, 0x7e, 0x17, 0x7d, 0x17, 0xb4, 0x9d, 0x37, 0x01,
	0x82, 0x66, 0x14, 0x2f, 0x8a, 0x96, 0x35, 0xb7, 0x4e, 0x76, 0x68, 0x44, 0x49, 0x7b, 0x17, 0xbb,
	0xa2, 0xa5, 0xe3, 0xb7, 0xda, 0x64, 0xbe, 0x36, 0xd4, 0xa2, 0x68, 0xe1, 0xab, 0xbc, 0xfa, 0x79,
	0x4c, 0xf1, 0x20, 0x3c, 0x72, 0xfe, 0xd1, 0x73, 0xe8, 0x0c, 0x3c, 0xad, 0x8a, 0xb5, 0xca, 0xb5,
	0xa9, 0x1e, 0x26, 0xb0, 0xe4, 0x1c, 0xfb, 0x24, 0xac, 0xd1, 0xa8, 0x90, 0xda, 0xa3, 0xe5, 0xab,
	0xbc, 0x5a, 0x76, 0x45, 0x6b, 0xd3, 0x50, 0x52, 0x51, 0xfe, 0x0b, 0xa0, 0x93, 0xbd, 0x26, 0xdb,
	0x19, 0xe1, 0x26, 0x3d, 0xf3, 0xaa, 0xfd, 0xb2, 0xbe, 0x19, 0xde, 0xad, 0xa2, 0x5b, 0x4d, 0xb4,
	0xe6, 0xf3, 0x91, 0x7d, 0x95, 0x57, 0xbf, 0xa8, 0xa8, 0x1e, 0x44, 0x47, 0xd5, 0xa6, 0x55, 0x57,
	0xf7, 0x13, 0x00, 0x07, 0xcc, 0x4e, 0xf3, 0xef, 0x09, 0xd4, 0x06, 0x6f, 0x80, 0xb6, 0x13, 0xa0,
	0xc1, 0x68, 0x83, 0xd6, 0xa3, 0xd9, 0x36, 0xed, 0x2a, 0xaf, 0xc6, 0xdf, 0x33, 0x12, 0x35, 0x2e,
	0x0f, 0x43, 0x5d, 0xb5, 0x3c, 0xb5, 0x63, 0x76, 0x47, 0x87, 0x4e, 0xd9, 0x54, 0x25, 0xc1, 0x85,
	0xaf, 0xc1, 0x51, 0xc6, 0x4b, 0x2a, 0x07, 0xed, 0x30, 0x59, 0x5a, 0x79, 0x9a, 0xf1, 0xe7, 0xef,
	0x13, 0x92, 0x88, 0xed, 0x44, 0xe6, 0xf2, 0x7a, 0x99, 0xf1, 0x72, 0x9d, 0x7b, 0xd4, 0x2f, 0x0b,
	0x6f, 0xa7, 0x5c, 0xe3, 0x65, 0xc6, 0x6f, 0x16, 0xee, 0x5a, 0x79, 0x7a, 0x89, 0x57, 0x07, 0xf4,
	0x31, 0x3b, 0xf7, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc3, 0x49, 0x54, 0x8f, 0xfe, 0x24, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CertificatesClient is the client API for Certificates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CertificatesClient interface {
	GetCertificateSigningRequest(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CertificateSigningRequest, error)
	AddAppleCertificate(ctx context.Context, in *FileBytes, opts ...grpc.CallOption) (*CertificateData, error)
	UpdateAppleCertificate(ctx context.Context, in *FileBytes, opts ...grpc.CallOption) (*CertificateData, error)
	GetAppleCertificateData(ctx context.Context, in *PassTypeIdentifier, opts ...grpc.CallOption) (*CertificateData, error)
	ListAppleCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Certificates_ListAppleCertificatesClient, error)
	CountAppleCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error)
	AddPrivateKey(ctx context.Context, in *PrivateKeyRequest, opts ...grpc.CallOption) (*Id, error)
	DeletePrivateKey(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error)
	ListPrivateKeys(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Certificates_ListPrivateKeysClient, error)
	CountPrivateKeys(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error)
	AddTLSCertificate(ctx context.Context, in *TLSCertificateRequest, opts ...grpc.CallOption) (*Id, error)
	DeleteTLSCertificate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error)
	ListTLSCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Certificates_ListTLSCertificatesClient, error)
	CountTLSCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error)
}

type certificatesClient struct {
	cc *grpc.ClientConn
}

func NewCertificatesClient(cc *grpc.ClientConn) CertificatesClient {
	return &certificatesClient{cc}
}

func (c *certificatesClient) GetCertificateSigningRequest(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CertificateSigningRequest, error) {
	out := new(CertificateSigningRequest)
	err := c.cc.Invoke(ctx, "/io.Certificates/getCertificateSigningRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) AddAppleCertificate(ctx context.Context, in *FileBytes, opts ...grpc.CallOption) (*CertificateData, error) {
	out := new(CertificateData)
	err := c.cc.Invoke(ctx, "/io.Certificates/addAppleCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) UpdateAppleCertificate(ctx context.Context, in *FileBytes, opts ...grpc.CallOption) (*CertificateData, error) {
	out := new(CertificateData)
	err := c.cc.Invoke(ctx, "/io.Certificates/updateAppleCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) GetAppleCertificateData(ctx context.Context, in *PassTypeIdentifier, opts ...grpc.CallOption) (*CertificateData, error) {
	out := new(CertificateData)
	err := c.cc.Invoke(ctx, "/io.Certificates/getAppleCertificateData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) ListAppleCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Certificates_ListAppleCertificatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Certificates_serviceDesc.Streams[0], "/io.Certificates/listAppleCertificates", opts...)
	if err != nil {
		return nil, err
	}
	x := &certificatesListAppleCertificatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Certificates_ListAppleCertificatesClient interface {
	Recv() (*CertificateData, error)
	grpc.ClientStream
}

type certificatesListAppleCertificatesClient struct {
	grpc.ClientStream
}

func (x *certificatesListAppleCertificatesClient) Recv() (*CertificateData, error) {
	m := new(CertificateData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *certificatesClient) CountAppleCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error) {
	out := new(Count)
	err := c.cc.Invoke(ctx, "/io.Certificates/countAppleCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) AddPrivateKey(ctx context.Context, in *PrivateKeyRequest, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Certificates/addPrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) DeletePrivateKey(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Certificates/deletePrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) ListPrivateKeys(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Certificates_ListPrivateKeysClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Certificates_serviceDesc.Streams[1], "/io.Certificates/listPrivateKeys", opts...)
	if err != nil {
		return nil, err
	}
	x := &certificatesListPrivateKeysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Certificates_ListPrivateKeysClient interface {
	Recv() (*PrivateKeyData, error)
	grpc.ClientStream
}

type certificatesListPrivateKeysClient struct {
	grpc.ClientStream
}

func (x *certificatesListPrivateKeysClient) Recv() (*PrivateKeyData, error) {
	m := new(PrivateKeyData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *certificatesClient) CountPrivateKeys(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error) {
	out := new(Count)
	err := c.cc.Invoke(ctx, "/io.Certificates/countPrivateKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) AddTLSCertificate(ctx context.Context, in *TLSCertificateRequest, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Certificates/addTLSCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) DeleteTLSCertificate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Certificates/deleteTLSCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificatesClient) ListTLSCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Certificates_ListTLSCertificatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Certificates_serviceDesc.Streams[2], "/io.Certificates/listTLSCertificates", opts...)
	if err != nil {
		return nil, err
	}
	x := &certificatesListTLSCertificatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Certificates_ListTLSCertificatesClient interface {
	Recv() (*TLSCertificateData, error)
	grpc.ClientStream
}

type certificatesListTLSCertificatesClient struct {
	grpc.ClientStream
}

func (x *certificatesListTLSCertificatesClient) Recv() (*TLSCertificateData, error) {
	m := new(TLSCertificateData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *certificatesClient) CountTLSCertificates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error) {
	out := new(Count)
	err := c.cc.Invoke(ctx, "/io.Certificates/countTLSCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertificatesServer is the server API for Certificates service.
type CertificatesServer interface {
	GetCertificateSigningRequest(context.Context, *empty.Empty) (*CertificateSigningRequest, error)
	AddAppleCertificate(context.Context, *FileBytes) (*CertificateData, error)
	UpdateAppleCertificate(context.Context, *FileBytes) (*CertificateData, error)
	GetAppleCertificateData(context.Context, *PassTypeIdentifier) (*CertificateData, error)
	ListAppleCertificates(*Pagination, Certificates_ListAppleCertificatesServer) error
	CountAppleCertificates(context.Context, *Pagination) (*Count, error)
	AddPrivateKey(context.Context, *PrivateKeyRequest) (*Id, error)
	DeletePrivateKey(context.Context, *Id) (*empty.Empty, error)
	ListPrivateKeys(*Pagination, Certificates_ListPrivateKeysServer) error
	CountPrivateKeys(context.Context, *Pagination) (*Count, error)
	AddTLSCertificate(context.Context, *TLSCertificateRequest) (*Id, error)
	DeleteTLSCertificate(context.Context, *Id) (*empty.Empty, error)
	ListTLSCertificates(*Pagination, Certificates_ListTLSCertificatesServer) error
	CountTLSCertificates(context.Context, *Pagination) (*Count, error)
}

// UnimplementedCertificatesServer can be embedded to have forward compatible implementations.
type UnimplementedCertificatesServer struct {
}

func (*UnimplementedCertificatesServer) GetCertificateSigningRequest(ctx context.Context, req *empty.Empty) (*CertificateSigningRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCertificateSigningRequest not implemented")
}
func (*UnimplementedCertificatesServer) AddAppleCertificate(ctx context.Context, req *FileBytes) (*CertificateData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAppleCertificate not implemented")
}
func (*UnimplementedCertificatesServer) UpdateAppleCertificate(ctx context.Context, req *FileBytes) (*CertificateData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAppleCertificate not implemented")
}
func (*UnimplementedCertificatesServer) GetAppleCertificateData(ctx context.Context, req *PassTypeIdentifier) (*CertificateData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppleCertificateData not implemented")
}
func (*UnimplementedCertificatesServer) ListAppleCertificates(req *Pagination, srv Certificates_ListAppleCertificatesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListAppleCertificates not implemented")
}
func (*UnimplementedCertificatesServer) CountAppleCertificates(ctx context.Context, req *Pagination) (*Count, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountAppleCertificates not implemented")
}
func (*UnimplementedCertificatesServer) AddPrivateKey(ctx context.Context, req *PrivateKeyRequest) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPrivateKey not implemented")
}
func (*UnimplementedCertificatesServer) DeletePrivateKey(ctx context.Context, req *Id) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePrivateKey not implemented")
}
func (*UnimplementedCertificatesServer) ListPrivateKeys(req *Pagination, srv Certificates_ListPrivateKeysServer) error {
	return status.Errorf(codes.Unimplemented, "method ListPrivateKeys not implemented")
}
func (*UnimplementedCertificatesServer) CountPrivateKeys(ctx context.Context, req *Pagination) (*Count, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountPrivateKeys not implemented")
}
func (*UnimplementedCertificatesServer) AddTLSCertificate(ctx context.Context, req *TLSCertificateRequest) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTLSCertificate not implemented")
}
func (*UnimplementedCertificatesServer) DeleteTLSCertificate(ctx context.Context, req *Id) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTLSCertificate not implemented")
}
func (*UnimplementedCertificatesServer) ListTLSCertificates(req *Pagination, srv Certificates_ListTLSCertificatesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTLSCertificates not implemented")
}
func (*UnimplementedCertificatesServer) CountTLSCertificates(ctx context.Context, req *Pagination) (*Count, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountTLSCertificates not implemented")
}

func RegisterCertificatesServer(s *grpc.Server, srv CertificatesServer) {
	s.RegisterService(&_Certificates_serviceDesc, srv)
}

func _Certificates_GetCertificateSigningRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).GetCertificateSigningRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/GetCertificateSigningRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).GetCertificateSigningRequest(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_AddAppleCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileBytes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).AddAppleCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/AddAppleCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).AddAppleCertificate(ctx, req.(*FileBytes))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_UpdateAppleCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileBytes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).UpdateAppleCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/UpdateAppleCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).UpdateAppleCertificate(ctx, req.(*FileBytes))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_GetAppleCertificateData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassTypeIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).GetAppleCertificateData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/GetAppleCertificateData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).GetAppleCertificateData(ctx, req.(*PassTypeIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_ListAppleCertificates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CertificatesServer).ListAppleCertificates(m, &certificatesListAppleCertificatesServer{stream})
}

type Certificates_ListAppleCertificatesServer interface {
	Send(*CertificateData) error
	grpc.ServerStream
}

type certificatesListAppleCertificatesServer struct {
	grpc.ServerStream
}

func (x *certificatesListAppleCertificatesServer) Send(m *CertificateData) error {
	return x.ServerStream.SendMsg(m)
}

func _Certificates_CountAppleCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).CountAppleCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/CountAppleCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).CountAppleCertificates(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_AddPrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrivateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).AddPrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/AddPrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).AddPrivateKey(ctx, req.(*PrivateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_DeletePrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).DeletePrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/DeletePrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).DeletePrivateKey(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_ListPrivateKeys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CertificatesServer).ListPrivateKeys(m, &certificatesListPrivateKeysServer{stream})
}

type Certificates_ListPrivateKeysServer interface {
	Send(*PrivateKeyData) error
	grpc.ServerStream
}

type certificatesListPrivateKeysServer struct {
	grpc.ServerStream
}

func (x *certificatesListPrivateKeysServer) Send(m *PrivateKeyData) error {
	return x.ServerStream.SendMsg(m)
}

func _Certificates_CountPrivateKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).CountPrivateKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/CountPrivateKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).CountPrivateKeys(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_AddTLSCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).AddTLSCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/AddTLSCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).AddTLSCertificate(ctx, req.(*TLSCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_DeleteTLSCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).DeleteTLSCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/DeleteTLSCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).DeleteTLSCertificate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificates_ListTLSCertificates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CertificatesServer).ListTLSCertificates(m, &certificatesListTLSCertificatesServer{stream})
}

type Certificates_ListTLSCertificatesServer interface {
	Send(*TLSCertificateData) error
	grpc.ServerStream
}

type certificatesListTLSCertificatesServer struct {
	grpc.ServerStream
}

func (x *certificatesListTLSCertificatesServer) Send(m *TLSCertificateData) error {
	return x.ServerStream.SendMsg(m)
}

func _Certificates_CountTLSCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificatesServer).CountTLSCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Certificates/CountTLSCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificatesServer).CountTLSCertificates(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

var _Certificates_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Certificates",
	HandlerType: (*CertificatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getCertificateSigningRequest",
			Handler:    _Certificates_GetCertificateSigningRequest_Handler,
		},
		{
			MethodName: "addAppleCertificate",
			Handler:    _Certificates_AddAppleCertificate_Handler,
		},
		{
			MethodName: "updateAppleCertificate",
			Handler:    _Certificates_UpdateAppleCertificate_Handler,
		},
		{
			MethodName: "getAppleCertificateData",
			Handler:    _Certificates_GetAppleCertificateData_Handler,
		},
		{
			MethodName: "countAppleCertificates",
			Handler:    _Certificates_CountAppleCertificates_Handler,
		},
		{
			MethodName: "addPrivateKey",
			Handler:    _Certificates_AddPrivateKey_Handler,
		},
		{
			MethodName: "deletePrivateKey",
			Handler:    _Certificates_DeletePrivateKey_Handler,
		},
		{
			MethodName: "countPrivateKeys",
			Handler:    _Certificates_CountPrivateKeys_Handler,
		},
		{
			MethodName: "addTLSCertificate",
			Handler:    _Certificates_AddTLSCertificate_Handler,
		},
		{
			MethodName: "deleteTLSCertificate",
			Handler:    _Certificates_DeleteTLSCertificate_Handler,
		},
		{
			MethodName: "countTLSCertificates",
			Handler:    _Certificates_CountTLSCertificates_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "listAppleCertificates",
			Handler:       _Certificates_ListAppleCertificates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listPrivateKeys",
			Handler:       _Certificates_ListPrivateKeys_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listTLSCertificates",
			Handler:       _Certificates_ListTLSCertificates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc.proto",
}

// TemplatesClient is the client API for Templates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TemplatesClient interface {
	CreateTemplate(ctx context.Context, in *PassTemplate, opts ...grpc.CallOption) (*Id, error)
	UpdateTemplate(ctx context.Context, in *PassTemplate, opts ...grpc.CallOption) (*PassTemplate, error)
	GetTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PassTemplateResponse, error)
	GetDefaultTemplate(ctx context.Context, in *DefaultTemplateRequest, opts ...grpc.CallOption) (*PassTemplate, error)
	CopyTemplate(ctx context.Context, in *CopyTemplateInput, opts ...grpc.CallOption) (*Id, error)
	DeleteTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error)
	ListTemplatesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Templates_ListTemplatesForUserClient, error)
	ListTemplates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Templates_ListTemplatesClient, error)
	CountTemplates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error)
	CountTemplatesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error)
}

type templatesClient struct {
	cc *grpc.ClientConn
}

func NewTemplatesClient(cc *grpc.ClientConn) TemplatesClient {
	return &templatesClient{cc}
}

func (c *templatesClient) CreateTemplate(ctx context.Context, in *PassTemplate, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Templates/createTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) UpdateTemplate(ctx context.Context, in *PassTemplate, opts ...grpc.CallOption) (*PassTemplate, error) {
	out := new(PassTemplate)
	err := c.cc.Invoke(ctx, "/io.Templates/updateTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) GetTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PassTemplateResponse, error) {
	out := new(PassTemplateResponse)
	err := c.cc.Invoke(ctx, "/io.Templates/getTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) GetDefaultTemplate(ctx context.Context, in *DefaultTemplateRequest, opts ...grpc.CallOption) (*PassTemplate, error) {
	out := new(PassTemplate)
	err := c.cc.Invoke(ctx, "/io.Templates/getDefaultTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) CopyTemplate(ctx context.Context, in *CopyTemplateInput, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Templates/copyTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) DeleteTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Templates/deleteTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) ListTemplatesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Templates_ListTemplatesForUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Templates_serviceDesc.Streams[0], "/io.Templates/listTemplatesForUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &templatesListTemplatesForUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Templates_ListTemplatesForUserClient interface {
	Recv() (*PassTemplateResponse, error)
	grpc.ClientStream
}

type templatesListTemplatesForUserClient struct {
	grpc.ClientStream
}

func (x *templatesListTemplatesForUserClient) Recv() (*PassTemplateResponse, error) {
	m := new(PassTemplateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *templatesClient) ListTemplates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Templates_ListTemplatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Templates_serviceDesc.Streams[1], "/io.Templates/listTemplates", opts...)
	if err != nil {
		return nil, err
	}
	x := &templatesListTemplatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Templates_ListTemplatesClient interface {
	Recv() (*PassTemplateResponse, error)
	grpc.ClientStream
}

type templatesListTemplatesClient struct {
	grpc.ClientStream
}

func (x *templatesListTemplatesClient) Recv() (*PassTemplateResponse, error) {
	m := new(PassTemplateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *templatesClient) CountTemplates(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error) {
	out := new(Count)
	err := c.cc.Invoke(ctx, "/io.Templates/countTemplates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) CountTemplatesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error) {
	out := new(Count)
	err := c.cc.Invoke(ctx, "/io.Templates/countTemplatesForUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TemplatesServer is the server API for Templates service.
type TemplatesServer interface {
	CreateTemplate(context.Context, *PassTemplate) (*Id, error)
	UpdateTemplate(context.Context, *PassTemplate) (*PassTemplate, error)
	GetTemplate(context.Context, *Id) (*PassTemplateResponse, error)
	GetDefaultTemplate(context.Context, *DefaultTemplateRequest) (*PassTemplate, error)
	CopyTemplate(context.Context, *CopyTemplateInput) (*Id, error)
	DeleteTemplate(context.Context, *Id) (*empty.Empty, error)
	ListTemplatesForUser(*Pagination, Templates_ListTemplatesForUserServer) error
	ListTemplates(*Pagination, Templates_ListTemplatesServer) error
	CountTemplates(context.Context, *Pagination) (*Count, error)
	CountTemplatesForUser(context.Context, *Pagination) (*Count, error)
}

// UnimplementedTemplatesServer can be embedded to have forward compatible implementations.
type UnimplementedTemplatesServer struct {
}

func (*UnimplementedTemplatesServer) CreateTemplate(ctx context.Context, req *PassTemplate) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTemplate not implemented")
}
func (*UnimplementedTemplatesServer) UpdateTemplate(ctx context.Context, req *PassTemplate) (*PassTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTemplate not implemented")
}
func (*UnimplementedTemplatesServer) GetTemplate(ctx context.Context, req *Id) (*PassTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemplate not implemented")
}
func (*UnimplementedTemplatesServer) GetDefaultTemplate(ctx context.Context, req *DefaultTemplateRequest) (*PassTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultTemplate not implemented")
}
func (*UnimplementedTemplatesServer) CopyTemplate(ctx context.Context, req *CopyTemplateInput) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyTemplate not implemented")
}
func (*UnimplementedTemplatesServer) DeleteTemplate(ctx context.Context, req *Id) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTemplate not implemented")
}
func (*UnimplementedTemplatesServer) ListTemplatesForUser(req *Pagination, srv Templates_ListTemplatesForUserServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTemplatesForUser not implemented")
}
func (*UnimplementedTemplatesServer) ListTemplates(req *Pagination, srv Templates_ListTemplatesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTemplates not implemented")
}
func (*UnimplementedTemplatesServer) CountTemplates(ctx context.Context, req *Pagination) (*Count, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountTemplates not implemented")
}
func (*UnimplementedTemplatesServer) CountTemplatesForUser(ctx context.Context, req *Pagination) (*Count, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountTemplatesForUser not implemented")
}

func RegisterTemplatesServer(s *grpc.Server, srv TemplatesServer) {
	s.RegisterService(&_Templates_serviceDesc, srv)
}

func _Templates_CreateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).CreateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/CreateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).CreateTemplate(ctx, req.(*PassTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_UpdateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).UpdateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/UpdateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).UpdateTemplate(ctx, req.(*PassTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_GetTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).GetTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/GetTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).GetTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_GetDefaultTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).GetDefaultTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/GetDefaultTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).GetDefaultTemplate(ctx, req.(*DefaultTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_CopyTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyTemplateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).CopyTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/CopyTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).CopyTemplate(ctx, req.(*CopyTemplateInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_DeleteTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).DeleteTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/DeleteTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).DeleteTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_ListTemplatesForUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TemplatesServer).ListTemplatesForUser(m, &templatesListTemplatesForUserServer{stream})
}

type Templates_ListTemplatesForUserServer interface {
	Send(*PassTemplateResponse) error
	grpc.ServerStream
}

type templatesListTemplatesForUserServer struct {
	grpc.ServerStream
}

func (x *templatesListTemplatesForUserServer) Send(m *PassTemplateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Templates_ListTemplates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TemplatesServer).ListTemplates(m, &templatesListTemplatesServer{stream})
}

type Templates_ListTemplatesServer interface {
	Send(*PassTemplateResponse) error
	grpc.ServerStream
}

type templatesListTemplatesServer struct {
	grpc.ServerStream
}

func (x *templatesListTemplatesServer) Send(m *PassTemplateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Templates_CountTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).CountTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/CountTemplates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).CountTemplates(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_CountTemplatesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).CountTemplatesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Templates/CountTemplatesForUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).CountTemplatesForUser(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

var _Templates_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Templates",
	HandlerType: (*TemplatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createTemplate",
			Handler:    _Templates_CreateTemplate_Handler,
		},
		{
			MethodName: "updateTemplate",
			Handler:    _Templates_UpdateTemplate_Handler,
		},
		{
			MethodName: "getTemplate",
			Handler:    _Templates_GetTemplate_Handler,
		},
		{
			MethodName: "getDefaultTemplate",
			Handler:    _Templates_GetDefaultTemplate_Handler,
		},
		{
			MethodName: "copyTemplate",
			Handler:    _Templates_CopyTemplate_Handler,
		},
		{
			MethodName: "deleteTemplate",
			Handler:    _Templates_DeleteTemplate_Handler,
		},
		{
			MethodName: "countTemplates",
			Handler:    _Templates_CountTemplates_Handler,
		},
		{
			MethodName: "countTemplatesForUser",
			Handler:    _Templates_CountTemplatesForUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "listTemplatesForUser",
			Handler:       _Templates_ListTemplatesForUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listTemplates",
			Handler:       _Templates_ListTemplates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc.proto",
}

// ImagesClient is the client API for Images service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ImagesClient interface {
	SetProfileImage(ctx context.Context, in *ProfileImageInput, opts ...grpc.CallOption) (*empty.Empty, error)
	GetProfileImage(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Url, error)
	GetProfileImageById(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Url, error)
	CreateImages(ctx context.Context, in *CreateImageInput, opts ...grpc.CallOption) (*ImageIds, error)
	UpdateImage(ctx context.Context, in *UpdateImageInput, opts ...grpc.CallOption) (*ImageRecord, error)
	GetImageURL(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Url, error)
	// returns a zip bundle containing all images for that ID
	GetImageBundle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ImageBundle, error)
	GetImageData(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ImageRecord, error)
	GetLocalizedImageURL(ctx context.Context, in *LocalizedImageInput, opts ...grpc.CallOption) (*Url, error)
	DeleteImage(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error)
	DeleteLocalizedImage(ctx context.Context, in *LocalizedImageInput, opts ...grpc.CallOption) (*ImageRecord, error)
	ListImagesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Images_ListImagesForUserClient, error)
	ListImages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Images_ListImagesClient, error)
	CountImages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error)
	CountImagesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error)
}

type imagesClient struct {
	cc *grpc.ClientConn
}

func NewImagesClient(cc *grpc.ClientConn) ImagesClient {
	return &imagesClient{cc}
}

func (c *imagesClient) SetProfileImage(ctx context.Context, in *ProfileImageInput, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Images/setProfileImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetProfileImage(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Url, error) {
	out := new(Url)
	err := c.cc.Invoke(ctx, "/io.Images/getProfileImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetProfileImageById(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Url, error) {
	out := new(Url)
	err := c.cc.Invoke(ctx, "/io.Images/getProfileImageById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) CreateImages(ctx context.Context, in *CreateImageInput, opts ...grpc.CallOption) (*ImageIds, error) {
	out := new(ImageIds)
	err := c.cc.Invoke(ctx, "/io.Images/createImages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) UpdateImage(ctx context.Context, in *UpdateImageInput, opts ...grpc.CallOption) (*ImageRecord, error) {
	out := new(ImageRecord)
	err := c.cc.Invoke(ctx, "/io.Images/updateImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetImageURL(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Url, error) {
	out := new(Url)
	err := c.cc.Invoke(ctx, "/io.Images/getImageURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetImageBundle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ImageBundle, error) {
	out := new(ImageBundle)
	err := c.cc.Invoke(ctx, "/io.Images/getImageBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetImageData(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ImageRecord, error) {
	out := new(ImageRecord)
	err := c.cc.Invoke(ctx, "/io.Images/getImageData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetLocalizedImageURL(ctx context.Context, in *LocalizedImageInput, opts ...grpc.CallOption) (*Url, error) {
	out := new(Url)
	err := c.cc.Invoke(ctx, "/io.Images/getLocalizedImageURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) DeleteImage(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Images/deleteImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) DeleteLocalizedImage(ctx context.Context, in *LocalizedImageInput, opts ...grpc.CallOption) (*ImageRecord, error) {
	out := new(ImageRecord)
	err := c.cc.Invoke(ctx, "/io.Images/deleteLocalizedImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) ListImagesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Images_ListImagesForUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Images_serviceDesc.Streams[0], "/io.Images/listImagesForUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &imagesListImagesForUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Images_ListImagesForUserClient interface {
	Recv() (*ImageRecord, error)
	grpc.ClientStream
}

type imagesListImagesForUserClient struct {
	grpc.ClientStream
}

func (x *imagesListImagesForUserClient) Recv() (*ImageRecord, error) {
	m := new(ImageRecord)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *imagesClient) ListImages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Images_ListImagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Images_serviceDesc.Streams[1], "/io.Images/listImages", opts...)
	if err != nil {
		return nil, err
	}
	x := &imagesListImagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Images_ListImagesClient interface {
	Recv() (*ImageRecord, error)
	grpc.ClientStream
}

type imagesListImagesClient struct {
	grpc.ClientStream
}

func (x *imagesListImagesClient) Recv() (*ImageRecord, error) {
	m := new(ImageRecord)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *imagesClient) CountImages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error) {
	out := new(Count)
	err := c.cc.Invoke(ctx, "/io.Images/countImages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) CountImagesForUser(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*Count, error) {
	out := new(Count)
	err := c.cc.Invoke(ctx, "/io.Images/countImagesForUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImagesServer is the server API for Images service.
type ImagesServer interface {
	SetProfileImage(context.Context, *ProfileImageInput) (*empty.Empty, error)
	GetProfileImage(context.Context, *empty.Empty) (*Url, error)
	GetProfileImageById(context.Context, *Id) (*Url, error)
	CreateImages(context.Context, *CreateImageInput) (*ImageIds, error)
	UpdateImage(context.Context, *UpdateImageInput) (*ImageRecord, error)
	GetImageURL(context.Context, *Id) (*Url, error)
	// returns a zip bundle containing all images for that ID
	GetImageBundle(context.Context, *Id) (*ImageBundle, error)
	GetImageData(context.Context, *Id) (*ImageRecord, error)
	GetLocalizedImageURL(context.Context, *LocalizedImageInput) (*Url, error)
	DeleteImage(context.Context, *Id) (*empty.Empty, error)
	DeleteLocalizedImage(context.Context, *LocalizedImageInput) (*ImageRecord, error)
	ListImagesForUser(*Pagination, Images_ListImagesForUserServer) error
	ListImages(*Pagination, Images_ListImagesServer) error
	CountImages(context.Context, *Pagination) (*Count, error)
	CountImagesForUser(context.Context, *Pagination) (*Count, error)
}

// UnimplementedImagesServer can be embedded to have forward compatible implementations.
type UnimplementedImagesServer struct {
}

func (*UnimplementedImagesServer) SetProfileImage(ctx context.Context, req *ProfileImageInput) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProfileImage not implemented")
}
func (*UnimplementedImagesServer) GetProfileImage(ctx context.Context, req *empty.Empty) (*Url, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfileImage not implemented")
}
func (*UnimplementedImagesServer) GetProfileImageById(ctx context.Context, req *Id) (*Url, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfileImageById not implemented")
}
func (*UnimplementedImagesServer) CreateImages(ctx context.Context, req *CreateImageInput) (*ImageIds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateImages not implemented")
}
func (*UnimplementedImagesServer) UpdateImage(ctx context.Context, req *UpdateImageInput) (*ImageRecord, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateImage not implemented")
}
func (*UnimplementedImagesServer) GetImageURL(ctx context.Context, req *Id) (*Url, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageURL not implemented")
}
func (*UnimplementedImagesServer) GetImageBundle(ctx context.Context, req *Id) (*ImageBundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageBundle not implemented")
}
func (*UnimplementedImagesServer) GetImageData(ctx context.Context, req *Id) (*ImageRecord, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageData not implemented")
}
func (*UnimplementedImagesServer) GetLocalizedImageURL(ctx context.Context, req *LocalizedImageInput) (*Url, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocalizedImageURL not implemented")
}
func (*UnimplementedImagesServer) DeleteImage(ctx context.Context, req *Id) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}
func (*UnimplementedImagesServer) DeleteLocalizedImage(ctx context.Context, req *LocalizedImageInput) (*ImageRecord, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLocalizedImage not implemented")
}
func (*UnimplementedImagesServer) ListImagesForUser(req *Pagination, srv Images_ListImagesForUserServer) error {
	return status.Errorf(codes.Unimplemented, "method ListImagesForUser not implemented")
}
func (*UnimplementedImagesServer) ListImages(req *Pagination, srv Images_ListImagesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListImages not implemented")
}
func (*UnimplementedImagesServer) CountImages(ctx context.Context, req *Pagination) (*Count, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountImages not implemented")
}
func (*UnimplementedImagesServer) CountImagesForUser(ctx context.Context, req *Pagination) (*Count, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountImagesForUser not implemented")
}

func RegisterImagesServer(s *grpc.Server, srv ImagesServer) {
	s.RegisterService(&_Images_serviceDesc, srv)
}

func _Images_SetProfileImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProfileImageInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).SetProfileImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/SetProfileImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).SetProfileImage(ctx, req.(*ProfileImageInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetProfileImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetProfileImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/GetProfileImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetProfileImage(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetProfileImageById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetProfileImageById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/GetProfileImageById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetProfileImageById(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_CreateImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateImageInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).CreateImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/CreateImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).CreateImages(ctx, req.(*CreateImageInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_UpdateImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateImageInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).UpdateImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/UpdateImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).UpdateImage(ctx, req.(*UpdateImageInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetImageURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetImageURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/GetImageURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetImageURL(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetImageBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetImageBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/GetImageBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetImageBundle(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetImageData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetImageData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/GetImageData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetImageData(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetLocalizedImageURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalizedImageInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetLocalizedImageURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/GetLocalizedImageURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetLocalizedImageURL(ctx, req.(*LocalizedImageInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/DeleteImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).DeleteImage(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_DeleteLocalizedImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalizedImageInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).DeleteLocalizedImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/DeleteLocalizedImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).DeleteLocalizedImage(ctx, req.(*LocalizedImageInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_ListImagesForUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImagesServer).ListImagesForUser(m, &imagesListImagesForUserServer{stream})
}

type Images_ListImagesForUserServer interface {
	Send(*ImageRecord) error
	grpc.ServerStream
}

type imagesListImagesForUserServer struct {
	grpc.ServerStream
}

func (x *imagesListImagesForUserServer) Send(m *ImageRecord) error {
	return x.ServerStream.SendMsg(m)
}

func _Images_ListImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImagesServer).ListImages(m, &imagesListImagesServer{stream})
}

type Images_ListImagesServer interface {
	Send(*ImageRecord) error
	grpc.ServerStream
}

type imagesListImagesServer struct {
	grpc.ServerStream
}

func (x *imagesListImagesServer) Send(m *ImageRecord) error {
	return x.ServerStream.SendMsg(m)
}

func _Images_CountImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).CountImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/CountImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).CountImages(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_CountImagesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).CountImagesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Images/CountImagesForUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).CountImagesForUser(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

var _Images_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Images",
	HandlerType: (*ImagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setProfileImage",
			Handler:    _Images_SetProfileImage_Handler,
		},
		{
			MethodName: "getProfileImage",
			Handler:    _Images_GetProfileImage_Handler,
		},
		{
			MethodName: "getProfileImageById",
			Handler:    _Images_GetProfileImageById_Handler,
		},
		{
			MethodName: "createImages",
			Handler:    _Images_CreateImages_Handler,
		},
		{
			MethodName: "updateImage",
			Handler:    _Images_UpdateImage_Handler,
		},
		{
			MethodName: "getImageURL",
			Handler:    _Images_GetImageURL_Handler,
		},
		{
			MethodName: "getImageBundle",
			Handler:    _Images_GetImageBundle_Handler,
		},
		{
			MethodName: "getImageData",
			Handler:    _Images_GetImageData_Handler,
		},
		{
			MethodName: "getLocalizedImageURL",
			Handler:    _Images_GetLocalizedImageURL_Handler,
		},
		{
			MethodName: "deleteImage",
			Handler:    _Images_DeleteImage_Handler,
		},
		{
			MethodName: "deleteLocalizedImage",
			Handler:    _Images_DeleteLocalizedImage_Handler,
		},
		{
			MethodName: "countImages",
			Handler:    _Images_CountImages_Handler,
		},
		{
			MethodName: "countImagesForUser",
			Handler:    _Images_CountImagesForUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "listImagesForUser",
			Handler:       _Images_ListImagesForUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listImages",
			Handler:       _Images_ListImages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc.proto",
}

// UsersClient is the client API for Users service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UsersClient interface {
	UsernameExists(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Boolean, error)
	CreateUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*NewUserResponse, error)
	NewUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*JWT, error)
	Verify(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Boolean, error)
	ResendVerificationEmail(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Boolean, error)
	GetUser(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetUserResponse, error)
	Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JWT, error)
	ResetPassword(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*empty.Empty, error)
	GetProjectsForUser(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsForUserClient, error)
	GetProjects(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsClient, error)
	GetProjectByUuid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Project, error)
	GetProjectAndTemplateByShortCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ProjectByShortCodeResult, error)
}

type usersClient struct {
	cc *grpc.ClientConn
}

func NewUsersClient(cc *grpc.ClientConn) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) UsernameExists(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Boolean, error) {
	out := new(Boolean)
	err := c.cc.Invoke(ctx, "/io.Users/usernameExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) CreateUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*NewUserResponse, error) {
	out := new(NewUserResponse)
	err := c.cc.Invoke(ctx, "/io.Users/createUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) NewUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*JWT, error) {
	out := new(JWT)
	err := c.cc.Invoke(ctx, "/io.Users/newUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Verify(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Boolean, error) {
	out := new(Boolean)
	err := c.cc.Invoke(ctx, "/io.Users/verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ResendVerificationEmail(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Boolean, error) {
	out := new(Boolean)
	err := c.cc.Invoke(ctx, "/io.Users/resendVerificationEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetUser(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetUserResponse, error) {
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, "/io.Users/getUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JWT, error) {
	out := new(JWT)
	err := c.cc.Invoke(ctx, "/io.Users/login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ResetPassword(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Users/resetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectsForUser(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsForUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[0], "/io.Users/getProjectsForUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsForUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsForUserClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsForUserClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsForUserClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usersClient) GetProjects(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (Users_GetProjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Users_serviceDesc.Streams[1], "/io.Users/getProjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &usersGetProjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_GetProjectsClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type usersGetProjectsClient struct {
	grpc.ClientStream
}

func (x *usersGetProjectsClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usersClient) GetProjectByUuid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Project, error) {
	out := new(Project)
	err := c.cc.Invoke(ctx, "/io.Users/getProjectByUuid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectAndTemplateByShortCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ProjectByShortCodeResult, error) {
	out := new(ProjectByShortCodeResult)
	err := c.cc.Invoke(ctx, "/io.Users/getProjectAndTemplateByShortCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsersServer is the server API for Users service.
type UsersServer interface {
	UsernameExists(context.Context, *Id) (*Boolean, error)
	CreateUser(context.Context, *NewUser) (*NewUserResponse, error)
	NewUser(context.Context, *NewUser) (*JWT, error)
	Verify(context.Context, *Id) (*Boolean, error)
	ResendVerificationEmail(context.Context, *empty.Empty) (*Boolean, error)
	GetUser(context.Context, *empty.Empty) (*GetUserResponse, error)
	Login(context.Context, *Credentials) (*JWT, error)
	ResetPassword(context.Context, *Credentials) (*empty.Empty, error)
	GetProjectsForUser(*ProjectStatusFilter, Users_GetProjectsForUserServer) error
	GetProjects(*ProjectStatusFilter, Users_GetProjectsServer) error
	GetProjectByUuid(context.Context, *Id) (*Project, error)
	GetProjectAndTemplateByShortCode(context.Context, *Id) (*ProjectByShortCodeResult, error)
}

// UnimplementedUsersServer can be embedded to have forward compatible implementations.
type UnimplementedUsersServer struct {
}

func (*UnimplementedUsersServer) UsernameExists(ctx context.Context, req *Id) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsernameExists not implemented")
}
func (*UnimplementedUsersServer) CreateUser(ctx context.Context, req *NewUser) (*NewUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (*UnimplementedUsersServer) NewUser(ctx context.Context, req *NewUser) (*JWT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewUser not implemented")
}
func (*UnimplementedUsersServer) Verify(ctx context.Context, req *Id) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (*UnimplementedUsersServer) ResendVerificationEmail(ctx context.Context, req *empty.Empty) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResendVerificationEmail not implemented")
}
func (*UnimplementedUsersServer) GetUser(ctx context.Context, req *empty.Empty) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (*UnimplementedUsersServer) Login(ctx context.Context, req *Credentials) (*JWT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (*UnimplementedUsersServer) ResetPassword(ctx context.Context, req *Credentials) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (*UnimplementedUsersServer) GetProjectsForUser(req *ProjectStatusFilter, srv Users_GetProjectsForUserServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsForUser not implemented")
}
func (*UnimplementedUsersServer) GetProjects(req *ProjectStatusFilter, srv Users_GetProjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}
func (*UnimplementedUsersServer) GetProjectByUuid(ctx context.Context, req *Id) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectByUuid not implemented")
}
func (*UnimplementedUsersServer) GetProjectAndTemplateByShortCode(ctx context.Context, req *Id) (*ProjectByShortCodeResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectAndTemplateByShortCode not implemented")
}

func RegisterUsersServer(s *grpc.Server, srv UsersServer) {
	s.RegisterService(&_Users_serviceDesc, srv)
}

func _Users_UsernameExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UsernameExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/UsernameExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UsernameExists(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateUser(ctx, req.(*NewUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_NewUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).NewUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/NewUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).NewUser(ctx, req.(*NewUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).Verify(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ResendVerificationEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ResendVerificationEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/ResendVerificationEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ResendVerificationEmail(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetUser(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).Login(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/ResetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ResetPassword(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectsForUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectStatusFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsForUser(m, &usersGetProjectsForUserServer{stream})
}

type Users_GetProjectsForUserServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsForUserServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsForUserServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _Users_GetProjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectStatusFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjects(m, &usersGetProjectsServer{stream})
}

type Users_GetProjectsServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type usersGetProjectsServer struct {
	grpc.ServerStream
}

func (x *usersGetProjectsServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _Users_GetProjectByUuid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetProjectByUuid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/GetProjectByUuid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetProjectByUuid(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectAndTemplateByShortCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetProjectAndTemplateByShortCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Users/GetProjectAndTemplateByShortCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetProjectAndTemplateByShortCode(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _Users_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "usernameExists",
			Handler:    _Users_UsernameExists_Handler,
		},
		{
			MethodName: "createUser",
			Handler:    _Users_CreateUser_Handler,
		},
		{
			MethodName: "newUser",
			Handler:    _Users_NewUser_Handler,
		},
		{
			MethodName: "verify",
			Handler:    _Users_Verify_Handler,
		},
		{
			MethodName: "resendVerificationEmail",
			Handler:    _Users_ResendVerificationEmail_Handler,
		},
		{
			MethodName: "getUser",
			Handler:    _Users_GetUser_Handler,
		},
		{
			MethodName: "login",
			Handler:    _Users_Login_Handler,
		},
		{
			MethodName: "resetPassword",
			Handler:    _Users_ResetPassword_Handler,
		},
		{
			MethodName: "getProjectByUuid",
			Handler:    _Users_GetProjectByUuid_Handler,
		},
		{
			MethodName: "getProjectAndTemplateByShortCode",
			Handler:    _Users_GetProjectAndTemplateByShortCode_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getProjectsForUser",
			Handler:       _Users_GetProjectsForUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjects",
			Handler:       _Users_GetProjects_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc.proto",
}

// MessagesClient is the client API for Messages service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MessagesClient interface {
	SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Id, error)
	GetMessages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Messages_GetMessagesClient, error)
}

type messagesClient struct {
	cc *grpc.ClientConn
}

func NewMessagesClient(cc *grpc.ClientConn) MessagesClient {
	return &messagesClient{cc}
}

func (c *messagesClient) SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Messages/sendMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagesClient) GetMessages(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Messages_GetMessagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Messages_serviceDesc.Streams[0], "/io.Messages/getMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &messagesGetMessagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Messages_GetMessagesClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type messagesGetMessagesClient struct {
	grpc.ClientStream
}

func (x *messagesGetMessagesClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MessagesServer is the server API for Messages service.
type MessagesServer interface {
	SendMessage(context.Context, *Message) (*Id, error)
	GetMessages(*Pagination, Messages_GetMessagesServer) error
}

// UnimplementedMessagesServer can be embedded to have forward compatible implementations.
type UnimplementedMessagesServer struct {
}

func (*UnimplementedMessagesServer) SendMessage(ctx context.Context, req *Message) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (*UnimplementedMessagesServer) GetMessages(req *Pagination, srv Messages_GetMessagesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetMessages not implemented")
}

func RegisterMessagesServer(s *grpc.Server, srv MessagesServer) {
	s.RegisterService(&_Messages_serviceDesc, srv)
}

func _Messages_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagesServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Messages/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagesServer).SendMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Messages_GetMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MessagesServer).GetMessages(m, &messagesGetMessagesServer{stream})
}

type Messages_GetMessagesServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type messagesGetMessagesServer struct {
	grpc.ServerStream
}

func (x *messagesGetMessagesServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

var _Messages_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Messages",
	HandlerType: (*MessagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "sendMessage",
			Handler:    _Messages_SendMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getMessages",
			Handler:       _Messages_GetMessages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc.proto",
}

// DistributionClient is the client API for Distribution service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DistributionClient interface {
	SendWelcomeEmail(ctx context.Context, in *EmailDistributionRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type distributionClient struct {
	cc *grpc.ClientConn
}

func NewDistributionClient(cc *grpc.ClientConn) DistributionClient {
	return &distributionClient{cc}
}

func (c *distributionClient) SendWelcomeEmail(ctx context.Context, in *EmailDistributionRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/io.Distribution/sendWelcomeEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DistributionServer is the server API for Distribution service.
type DistributionServer interface {
	SendWelcomeEmail(context.Context, *EmailDistributionRequest) (*empty.Empty, error)
}

// UnimplementedDistributionServer can be embedded to have forward compatible implementations.
type UnimplementedDistributionServer struct {
}

func (*UnimplementedDistributionServer) SendWelcomeEmail(ctx context.Context, req *EmailDistributionRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendWelcomeEmail not implemented")
}

func RegisterDistributionServer(s *grpc.Server, srv DistributionServer) {
	s.RegisterService(&_Distribution_serviceDesc, srv)
}

func _Distribution_SendWelcomeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributionServer).SendWelcomeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Distribution/SendWelcomeEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributionServer).SendWelcomeEmail(ctx, req.(*EmailDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Distribution_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Distribution",
	HandlerType: (*DistributionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "sendWelcomeEmail",
			Handler:    _Distribution_SendWelcomeEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "io/core/a_rpc.proto",
}

// JobsClient is the client API for Jobs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JobsClient interface {
	ImportCsv(ctx context.Context, in *CsvImportRequest, opts ...grpc.CallOption) (*Id, error)
	GetJobs(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Jobs_GetJobsClient, error)
	GetJob(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Job, error)
}

type jobsClient struct {
	cc *grpc.ClientConn
}

func NewJobsClient(cc *grpc.ClientConn) JobsClient {
	return &jobsClient{cc}
}

func (c *jobsClient) ImportCsv(ctx context.Context, in *CsvImportRequest, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/io.Jobs/importCsv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsClient) GetJobs(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (Jobs_GetJobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Jobs_serviceDesc.Streams[0], "/io.Jobs/getJobs", opts...)
	if err != nil {
		return nil, err
	}
	x := &jobsGetJobsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Jobs_GetJobsClient interface {
	Recv() (*Job, error)
	grpc.ClientStream
}

type jobsGetJobsClient struct {
	grpc.ClientStream
}

func (x *jobsGetJobsClient) Recv() (*Job, error) {
	m := new(Job)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *jobsClient) GetJob(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := c.cc.Invoke(ctx, "/io.Jobs/getJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobsServer is the server API for Jobs service.
type JobsServer interface {
	ImportCsv(context.Context, *CsvImportRequest) (*Id, error)
	GetJobs(*Pagination, Jobs_GetJobsServer) error
	GetJob(context.Context, *Id) (*Job, error)
}

// UnimplementedJobsServer can be embedded to have forward compatible implementations.
type UnimplementedJobsServer struct {
}

func (*UnimplementedJobsServer) ImportCsv(ctx context.Context, req *CsvImportRequest) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportCsv not implemented")
}
func (*UnimplementedJobsServer) GetJobs(req *Pagination, srv Jobs_GetJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetJobs not implemented")
}
func (*UnimplementedJobsServer) GetJob(ctx context.Context, req *Id) (*Job, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}

func RegisterJobsServer(s *grpc.Server, srv JobsServer) {
	s.RegisterService(&_Jobs_serviceDesc, srv)
}

func _Jobs_ImportCsv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CsvImportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServer).ImportCsv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Jobs/ImportCsv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServer).ImportCsv(ctx, req.(*CsvImportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jobs_GetJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobsServer).GetJobs(m, &jobsGetJobsServer{stream})
}

type Jobs_GetJobsServer interface {
	Send(*Job) error
	grpc.ServerStream
}

type jobsGetJobsServer struct {
	grpc.ServerStream
}

func (x *jobsGetJobsServer) Send(m *Job) error {
	return x.ServerStream.SendMsg(m)
}

func _Jobs_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.Jobs/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServer).GetJob(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _Jobs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.Jobs",
	HandlerType: (*JobsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "importCsv",
			Handler:    _Jobs_ImportCsv_Handler,
		},
		{
			MethodName: "getJob",
			Handler:    _Jobs_GetJob_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getJobs",
			Handler:       _Jobs_GetJobs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc.proto",
}
